# Data Store Layer - Database DDL and Extensions

## Overview

The Data Store Layer defines the physical data storage using SQL DDL (Data Definition Language) with minimal custom extensions. This layer leverages standard SQL with database-specific extensions where necessary.

## Layer Characteristics

- **Standard**: SQL DDL (PostgreSQL, MySQL, SQLite dialects)
- **Custom Extensions**: Minimal (primarily comments and metadata)
- **Validation**: SQL parsers, database schema validators
- **Tooling**: Database migration tools, schema diff tools, ORMs

## Why SQL DDL + Minimal Extensions?

SQL DDL is the standard for database definition:
- **Industry Standard**: Universal language for database schemas
- **Database Native**: Direct execution by database engines
- **Version Controllable**: DDL files can be versioned in git
- **Migration Friendly**: Works with tools like Flyway, Liquibase, Alembic
- **Minimal Custom Invention**: Only add metadata via comments

## Core Database Entities

### Database
```yaml
Database:
  description: "Database instance containing schemas"
  attributes:
    name: string [PK]
    type: DatabaseType [enum]
    version: string
    charset: string (default: UTF8)
    collation: string

  contains:
    - schemas: DatabaseSchema[] (1..*)

  # Metadata (in comments)
  metadata:
    x-archimate-ref: string (Element.id reference)
    x-owner: string (team/person responsible)
    x-purpose: string (database purpose)

  enums:
    DatabaseType:
      - PostgreSQL
      - MySQL
      - SQLite
      - MariaDB
      - Oracle
      - SQL Server
```

### DatabaseSchema
```yaml
DatabaseSchema:
  description: "Logical grouping of database objects"
  attributes:
    name: string [PK within database]
    owner: string (database user/role)

  contains:
    - tables: Table[] (0..*)
    - views: View[] (0..*)
    - functions: Function[] (0..*)
    - sequences: Sequence[] (0..*)

  examples:
    - public       # Default schema
    - auth         # Authentication tables
    - analytics    # Analytics/reporting tables
    - audit        # Audit log tables
```

### Table
```yaml
Table:
  description: "Database table definition"
  attributes:
    name: string [PK within schema]
    schema: string (schema name)
    tablespace: string (optional)

  contains:
    - columns: Column[] (1..*)
    - constraints: Constraint[] (0..*)
    - indexes: Index[] (0..*)
    - triggers: Trigger[] (0..*)

  # Metadata (via COMMENT ON TABLE)
  metadata:
    x-json-schema: string (path to JSON Schema)
    x-archimate-ref: string (Element.id reference)
    x-owner: string
    x-retention: string (data retention policy)
    x-pii: boolean (contains PII)

  examples:
    - products
    - customers
    - orders
    - order_items
```

### Column
```yaml
Column:
  description: "Table column definition"
  attributes:
    name: string [PK within table]
    dataType: SQLDataType
    nullable: boolean (default: true)
    defaultValue: any (optional)
    generated: GenerationType (optional)

  # Metadata (via COMMENT ON COLUMN)
  metadata:
    description: string
    x-json-schema-path: string (JSONPath to schema property)
    x-pii: boolean
    x-encrypted: boolean
    x-sensitive: boolean

  enums:
    SQLDataType:
      # Integer types
      - SMALLINT
      - INTEGER
      - BIGINT
      - SERIAL
      - BIGSERIAL

      # Numeric types
      - DECIMAL(precision, scale)
      - NUMERIC(precision, scale)
      - REAL
      - DOUBLE PRECISION

      # Character types
      - CHAR(length)
      - VARCHAR(length)
      - TEXT

      # Binary types
      - BYTEA
      - BLOB

      # Boolean
      - BOOLEAN

      # Date/Time types
      - DATE
      - TIME
      - TIMESTAMP
      - TIMESTAMPTZ  # With timezone
      - INTERVAL

      # JSON types
      - JSON
      - JSONB  # Binary JSON (PostgreSQL)

      # UUID
      - UUID

      # Arrays (PostgreSQL)
      - INTEGER[]
      - TEXT[]
      - etc.

      # Enum types
      - ENUM('value1', 'value2', ...)

    GenerationType:
      - ALWAYS      # Always generated
      - BY_DEFAULT  # Generated by default, can be overridden
```

### Constraint
```yaml
Constraint:
  description: "Table constraint"
  attributes:
    name: string [PK within table]
    type: ConstraintType [required]

  # Type-specific attributes
  primaryKey:
    columns: string[] (column names)

  unique:
    columns: string[]

  foreignKey:
    columns: string[] (local columns)
    referencedTable: string
    referencedColumns: string[]
    onDelete: ReferentialAction
    onUpdate: ReferentialAction

  check:
    expression: string (SQL boolean expression)

  enums:
    ConstraintType:
      - PRIMARY_KEY
      - UNIQUE
      - FOREIGN_KEY
      - CHECK
      - EXCLUSION  # PostgreSQL-specific

    ReferentialAction:
      - CASCADE
      - SET_NULL
      - SET_DEFAULT
      - RESTRICT
      - NO_ACTION

  examples:
    # Primary key
    - name: products_pkey
      type: PRIMARY_KEY
      columns: [id]

    # Unique constraint
    - name: products_sku_unique
      type: UNIQUE
      columns: [sku]

    # Foreign key
    - name: order_items_product_fk
      type: FOREIGN_KEY
      columns: [product_id]
      referencedTable: products
      referencedColumns: [id]
      onDelete: RESTRICT
      onUpdate: CASCADE

    # Check constraint
    - name: products_price_positive
      type: CHECK
      expression: "price >= 0"
```

### Index
```yaml
Index:
  description: "Database index for query optimization"
  attributes:
    name: string [PK within table]
    columns: string[] | expression[] (column names or expressions)
    unique: boolean (default: false)
    method: IndexMethod (optional)
    where: string (partial index predicate, optional)
    include: string[] (included columns for covering index, optional)

  enums:
    IndexMethod:
      - BTREE     # Default, general purpose
      - HASH      # Equality operations only
      - GIN       # Generalized Inverted Index (arrays, JSON, full-text)
      - GIST      # Generalized Search Tree (geometric, full-text)
      - BRIN      # Block Range Index (very large tables)
      - SP-GIST   # Space-Partitioned GIST

  examples:
    # Simple index
    - name: idx_products_category
      columns: [category]
      method: BTREE

    # Composite index
    - name: idx_orders_customer_date
      columns: [customer_id, order_date]

    # Unique index
    - name: idx_products_sku
      columns: [sku]
      unique: true

    # Partial index
    - name: idx_products_active
      columns: [category]
      where: "deleted_at IS NULL"

    # Expression index
    - name: idx_products_name_lower
      columns: ["LOWER(name)"]

    # Covering index
    - name: idx_products_category_covering
      columns: [category]
      include: [name, price]

    # JSON index (GIN)
    - name: idx_products_metadata_gin
      columns: [metadata]
      method: GIN
```

### View
```yaml
View:
  description: "Database view"
  attributes:
    name: string [PK within schema]
    definition: string (SELECT statement)
    materialized: boolean (default: false)

  # Materialized view specific
  refresh:
    mode: RefreshMode (for materialized views)
    schedule: string (optional, cron expression)

  enums:
    RefreshMode:
      - ON_COMMIT
      - ON_DEMAND
      - SCHEDULED

  examples:
    # Regular view
    - name: vw_product_inventory
      definition: |
        SELECT p.id, p.name, p.sku, p.stock_quantity,
               CASE WHEN p.stock_quantity <= p.reorder_point
                    THEN 'REORDER'
                    ELSE 'OK'
               END as inventory_status
        FROM products p
        WHERE p.deleted_at IS NULL

    # Materialized view
    - name: mv_daily_sales
      materialized: true
      definition: |
        SELECT DATE(created_at) as sale_date,
               COUNT(*) as order_count,
               SUM(total_amount) as total_sales
        FROM orders
        GROUP BY DATE(created_at)
      refresh:
        mode: SCHEDULED
        schedule: "0 1 * * *"  # Daily at 1 AM
```

## Complete Example: Product Table

```sql
-- ============================================================
-- Table: products
-- Purpose: Product catalog
-- Schema Source: schemas/product.json
-- x-archimate-ref: data-object-product
-- x-owner: product-team
-- x-retention: 7years
-- x-pii: false
-- ============================================================

CREATE TABLE public.products (
    -- Primary Key
    -- x-json-schema-path: $.properties.id
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    -- Basic Information
    -- x-json-schema-path: $.properties.name
    name VARCHAR(200) NOT NULL,

    -- x-json-schema-path: $.properties.sku
    -- Stock Keeping Unit (format: AA1234)
    sku VARCHAR(10) NOT NULL,

    -- x-json-schema-path: $.properties.description
    description TEXT,

    -- Pricing
    -- x-json-schema-path: $.properties.price
    price DECIMAL(10, 2) NOT NULL CHECK (price >= 0),

    -- x-json-schema-path: $.properties.category
    category VARCHAR(50) NOT NULL,

    -- Inventory
    -- x-json-schema-path: $.properties.stockQuantity
    stock_quantity INTEGER NOT NULL DEFAULT 0 CHECK (stock_quantity >= 0),

    -- x-json-schema-path: $.properties.reorderPoint
    reorder_point INTEGER NOT NULL DEFAULT 10 CHECK (reorder_point >= 0),

    -- Metadata
    -- x-json-schema-path: $.properties.tags
    tags JSONB,

    -- x-json-schema-path: $.properties.images
    images JSONB,

    -- x-json-schema-path: $.properties.metadata
    metadata JSONB,

    -- Audit Fields
    -- x-json-schema-path: $.properties.createdAt
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,

    -- x-json-schema-path: $.properties.updatedAt
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,

    -- Soft Delete
    deleted_at TIMESTAMPTZ
);

-- ============================================================
-- Constraints
-- ============================================================

-- Unique SKU
ALTER TABLE products
    ADD CONSTRAINT products_sku_unique UNIQUE (sku);

-- Valid category values
ALTER TABLE products
    ADD CONSTRAINT products_category_check
    CHECK (category IN ('electronics', 'clothing', 'food', 'books', 'other'));

-- ============================================================
-- Indexes
-- ============================================================

-- Category index (for filtering)
CREATE INDEX idx_products_category
    ON products(category)
    WHERE deleted_at IS NULL;

-- SKU index (already unique, but explicit)
CREATE UNIQUE INDEX idx_products_sku
    ON products(sku)
    WHERE deleted_at IS NULL;

-- Name search index (case-insensitive)
CREATE INDEX idx_products_name_lower
    ON products(LOWER(name))
    WHERE deleted_at IS NULL;

-- JSON tags index (for tag searches)
CREATE INDEX idx_products_tags_gin
    ON products USING GIN(tags)
    WHERE deleted_at IS NULL;

-- Composite index for common queries
CREATE INDEX idx_products_category_price
    ON products(category, price DESC)
    WHERE deleted_at IS NULL;

-- Inventory alert index
CREATE INDEX idx_products_low_stock
    ON products(category)
    WHERE stock_quantity <= reorder_point
      AND deleted_at IS NULL;

-- ============================================================
-- Comments (for documentation and metadata)
-- ============================================================

COMMENT ON TABLE products IS
'Product catalog table.
x-json-schema: schemas/product.json
x-archimate-ref: data-object-product
x-owner: product-team
x-retention: 7years
x-pii: false';

COMMENT ON COLUMN products.id IS
'Unique product identifier (UUID).
x-json-schema-path: $.properties.id';

COMMENT ON COLUMN products.name IS
'Product name (1-200 characters).
x-json-schema-path: $.properties.name';

COMMENT ON COLUMN products.sku IS
'Stock Keeping Unit. Format: AA1234 (2 letters + 4 digits).
x-json-schema-path: $.properties.sku';

COMMENT ON COLUMN products.price IS
'Product price in USD. Must be non-negative.
x-json-schema-path: $.properties.price';

COMMENT ON COLUMN products.tags IS
'Product tags (JSON array of strings). Max 10 tags.
x-json-schema-path: $.properties.tags';

-- ============================================================
-- Triggers
-- ============================================================

-- Update timestamp trigger
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER products_updated_at
    BEFORE UPDATE ON products
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- ============================================================
-- Views
-- ============================================================

-- Active products view
CREATE OR REPLACE VIEW vw_products_active AS
SELECT id, name, sku, description, price, category,
       stock_quantity, reorder_point, tags,
       created_at, updated_at
FROM products
WHERE deleted_at IS NULL;

COMMENT ON VIEW vw_products_active IS
'View of active (non-deleted) products';

-- Low stock products view
CREATE OR REPLACE VIEW vw_products_low_stock AS
SELECT id, name, sku, category,
       stock_quantity, reorder_point,
       (reorder_point - stock_quantity) as shortage
FROM products
WHERE stock_quantity <= reorder_point
  AND deleted_at IS NULL
ORDER BY shortage DESC;

COMMENT ON VIEW vw_products_low_stock IS
'Products that need reordering (stock <= reorder point)';
```

## Migration Management

### Migration Files
```yaml
MigrationFile:
  description: "Database migration script"
  attributes:
    version: string (timestamp or sequence number)
    name: string (descriptive name)
    type: MigrationType

  structure:
    up: string (SQL to apply migration)
    down: string (SQL to rollback migration)

  enums:
    MigrationType:
      - schema     # Schema changes (DDL)
      - data       # Data migrations (DML)
      - seed       # Initial data seeding

  examples:
    # File: migrations/V001__create_products_table.sql
    -- Up migration
    CREATE TABLE products (...);

    # File: migrations/V001__create_products_table.down.sql
    -- Down migration
    DROP TABLE products;
```

### Migration Tools
```yaml
Tools:
  - Flyway: Java-based migration tool
  - Liquibase: XML/YAML/SQL migrations
  - Alembic: Python migrations (SQLAlchemy)
  - migrate: Go migrations
  - node-pg-migrate: Node.js/PostgreSQL
  - Atlas: Modern schema-as-code tool

Naming Convention:
  V{version}__{description}.sql
  Examples:
    - V001__create_products_table.sql
    - V002__add_products_category_index.sql
    - V003__migrate_product_categories.sql
```

## Integration Points

### To Data Model Layer (JSON Schema)
- Table COMMENT includes x-json-schema path
- Column COMMENT includes x-json-schema-path
- Ensures database matches logical data model
- Enables bidirectional sync

### To ArchiMate Technology Layer
- Table COMMENT includes x-archimate-ref to Artifact
- Enables traceability to architecture
- Links physical to logical

### To Security Layer
- Column metadata (x-pii, x-encrypted)
- Table metadata (x-retention, x-classification)
- Audit fields (created_at, updated_at, deleted_at)

### To APM/Observability Layer
- Slow query logging
- Table statistics
- Index usage monitoring
- Performance metrics

## Database-Specific Features

### PostgreSQL Extensions
```sql
-- Enable UUID generation
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";  -- For gen_random_uuid()

-- Full-text search
CREATE EXTENSION IF NOT EXISTS "pg_trgm";  -- Trigram matching
CREATE EXTENSION IF NOT EXISTS "unaccent";  -- Remove accents

-- Array and JSON operations
-- Built-in, no extension needed

-- Row-level security
ALTER TABLE products ENABLE ROW LEVEL SECURITY;

CREATE POLICY products_tenant_isolation ON products
    USING (tenant_id = current_setting('app.tenant_id')::UUID);
```

### MySQL/MariaDB Specifics
```sql
-- Storage engine
CREATE TABLE products (
    ...
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- Full-text index
CREATE FULLTEXT INDEX idx_products_fulltext
    ON products(name, description);

-- JSON (MySQL 5.7+)
ALTER TABLE products
    ADD COLUMN metadata JSON;
```

## Best Practices

1. **Use Migrations**: Never edit schema directly, always through migrations
2. **Version Control**: All DDL in git
3. **Naming Conventions**: Consistent naming (snake_case for PostgreSQL)
4. **Constraints**: Use database constraints for data integrity
5. **Indexes**: Index foreign keys and frequently queried columns
6. **Comments**: Document tables and columns extensively
7. **Soft Deletes**: Use deleted_at for audit trail
8. **Timestamps**: Always include created_at and updated_at
9. **Primary Keys**: Use UUID or BIGSERIAL for distributed systems
10. **Foreign Keys**: Always define for referential integrity
11. **Check Constraints**: Enforce business rules at database level
12. **Partial Indexes**: Use WHERE clause for filtered indexes
13. **Covering Indexes**: Include frequently accessed columns
14. **Metadata**: Use COMMENT for linking to other layers

## Validation

### Schema Validation
```yaml
Tools:
  - pg_dump: Export schema for comparison
  - migra: Schema diff tool
  - sqlfluff: SQL linter
  - dbdocs: Generate documentation
  - SchemaSpy: Schema visualization

Checks:
  - Foreign key integrity
  - Index coverage
  - Naming conventions
  - Missing indexes on foreign keys
  - Redundant indexes
  - Large varchar columns
  - Missing constraints
  - Missing timestamps
```

## Performance Considerations

```yaml
Indexes:
  - Index foreign keys
  - Composite indexes for multi-column queries
  - Partial indexes for filtered queries
  - Covering indexes for read-heavy queries
  - GIN/GIST for JSON, arrays, full-text

Partitioning:
  - Range partitioning (by date)
  - List partitioning (by category)
  - Hash partitioning (for even distribution)

Materialized Views:
  - Pre-compute complex aggregations
  - Refresh on schedule
  - Index materialized views

Connection Pooling:
  - PgBouncer, pgpool-II
  - Application-level pooling
```

This Data Store Layer provides a comprehensive approach to physical database design, leveraging standard SQL with minimal extensions for metadata and cross-layer integration.
