
You are a Software Architect.

I design system architectures considering scalability, maintainability, performance, and security. I create Architecture Decision Records (ADRs) with trade-off analyses and technical implementation plans.

## Task: Initial Analysis

Analyze the following requirement for project documentation_robotics:

**Title**: Add OpenTelemetry instrumentation for CLI debug builds
**Description**: ## Summary

Implement OpenTelemetry-based observability for the `dr` CLI tool to capture execution traces during development and debugging. This instrumentation should be completely eliminated from production builds via build-time configuration.

## Motivation

When Claude Code agents call the `dr` CLI, we need visibility into:
- Which commands are being invoked and with what arguments
- Which files are being read/modified
- Execution timing and error conditions
- Whether failures stem from incorrect agent usage (syntax errors) or actual bugs

This telemetry is strictly for local development/debuggingâ€”it should have zero overhead in production builds.

## Implementation Details

### 1. Build-time configuration (esbuild/tsup)

Use esbuild's `define` option to inject a build-time constant that controls telemetry inclusion:

```typescript
// build.config.ts or esbuild.config.js
import { defineConfig } from 'tsup';

export default defineConfig({
  entry: ['src/index.ts'],
  define: {
    'TELEMETRY_ENABLED': process.env.DR_TELEMETRY === 'true' ? 'true' : 'false',
  },
  esbuildOptions(options) {
    options.minifySyntax = true; // Required for dead branch elimination
  },
});
```

Build commands:
```bash
# Production build (no telemetry code in bundle)
npm run build

# Debug build with telemetry
DR_TELEMETRY=true npm run build:debug
```

### 2. TypeScript declarations for build-time constants

```typescript
// src/globals.d.ts
declare const TELEMETRY_ENABLED: boolean;
```

### 3. Guards that compile out completely

Create a telemetry module that wraps all OpenTelemetry calls:

```typescript
// src/telemetry/index.ts
import type { Span } from '@opentelemetry/api';

let sdk: NodeSDK | null = null;
let tracer: Tracer | null = null;

export function initTelemetry(): void {
  if (TELEMETRY_ENABLED) {
    // Dynamic import to ensure tree-shaking when disabled
    const { NodeSDK } = require('@opentelemetry/sdk-node');
    const { SimpleSpanProcessor } = require('@opentelemetry/sdk-trace-base');
    const { OTLPTraceExporter } = require('@opentelemetry/exporter-trace-otlp-http');
    const { trace } = require('@opentelemetry/api');
    
    const exporter = new OTLPTraceExporter({
      url: process.env.OTEL_EXPORTER_OTLP_ENDPOINT || 'http://localhost:4318/v1/traces',
      timeoutMillis: 1000, // Fast timeout for local dev
    });
    
    sdk = new NodeSDK({
      serviceName: 'dr-cli',
      spanProcessor: new SimpleSpanProcessor(exporter),
    });
    
    sdk.start();
    tracer = trace.getTracer('dr-cli');
  }
}

export function startSpan(name: string, attributes?: Record<string, unknown>): Span | null {
  if (TELEMETRY_ENABLED && tracer) {
    return tracer.startSpan(name, { attributes });
  }
  return null;
}

export function endSpan(span: Span | null): void {
  if (TELEMETRY_ENABLED && span) {
    span.end();
  }
}

export async function shutdownTelemetry(): Promise<void> {
  if (TELEMETRY_ENABLED && sdk) {
    try {
      await sdk.shutdown();
    } catch {
      // Silently ignore shutdown failures
    }
  }
}
```

**Key pattern**: Always use direct `if (TELEMETRY_ENABLED)` checksâ€”avoid storing the constant in intermediate variables which may not optimize as well.

### 4. Graceful failure exporter wrapper

Create an exporter that silently discards spans when the collector is unavailable:

```typescript
// src/telemetry/resilient-exporter.ts
import { SpanExporter, ReadableSpan } from '@opentelemetry/sdk-trace-base';
import { ExportResult, ExportResultCode } from '@opentelemetry/core';
import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-http';

export class ResilientOTLPExporter implements SpanExporter {
  private delegate: OTLPTraceExporter;
  private isConnected = true;
  private retryAfter = 0;

  constructor(config?: ConstructorParameters<typeof OTLPTraceExporter>[0]) {
    this.delegate = new OTLPTraceExporter({
      ...config,
      timeoutMillis: config?.timeoutMillis ?? 500, // Aggressive timeout
    });
  }

  export(spans: ReadableSpan[], resultCallback: (result: ExportResult) => void): void {
    // Skip if we recently failed (backoff for 30s)
    if (Date.now() < this.retryAfter) {
      resultCallback({ code: ExportResultCode.SUCCESS }); // Pretend success, discard
      return;
    }

    this.delegate.export(spans, (result) => {
      if (result.code === ExportResultCode.FAILED) {
        this.retryAfter = Date.now() + 30000; // Back off for 30 seconds
        // Still report success to SDK so it doesn't queue/retry
        resultCallback({ code: ExportResultCode.SUCCESS });
      } else {
        this.retryAfter = 0;
        resultCallback(result);
      }
    });
  }

  async shutdown(): Promise<void> {
    try {
      await this.delegate.shutdown();
    } catch {
      // Ignore shutdown failures
    }
  }
}
```

### 5. Local Jaeger receiver setup

Add a docker-compose file for local telemetry collection:

```yaml
# docker/docker-compose.telemetry.yml
services:
  jaeger:
    image: jaegertracing/all-in-one:latest
    container_name: dr-jaeger
    ports:
      - "16686:16686"  # Jaeger UI
      - "4317:4317"    # OTLP gRPC
      - "4318:4318"    # OTLP HTTP
    environment:
      - COLLECTOR_OTLP_ENABLED=true
```

Usage:
```bash
# Start the collector when you want to capture telemetry
docker compose -f docker/docker-compose.telemetry.yml up -d

# View traces at http://localhost:16686

# Stop when done
docker compose -f docker/docker-compose.telemetry.yml down
```

### 6. CLI instrumentation points

Instrument the main entry point to capture command execution:

```typescript
// src/cli.ts
import { initTelemetry, startSpan, endSpan, shutdownTelemetry } from './telemetry';

async function main() {
  initTelemetry();
  
  const rootSpan = startSpan('cli.execute', {
    'cli.command': process.argv[2],
    'cli.args': process.argv.slice(3).join(' '),
    'cli.cwd': process.cwd(),
    'cli.version': require('../package.json').version,
  });

  try {
    // Parse and execute command
    const result = await executeCommand(process.argv);
    
    if (TELEMETRY_ENABLED && rootSpan) {
      rootSpan.setStatus({ code: SpanStatusCode.OK });
    }
  } catch (error) {
    if (TELEMETRY_ENABLED && rootSpan) {
      rootSpan.setStatus({ 
        code: SpanStatusCode.ERROR,
        message: error instanceof Error ? error.message : String(error),
      });
      rootSpan.recordException(error as Error);
    }
    throw error;
  } finally {
    endSpan(rootSpan);
    await shutdownTelemetry();
  }
}
```

For file operations, add spans around file reads/writes:

```typescript
// src/utils/files.ts
export async function writeFile(path: string, content: string): Promise<void> {
  const span = startSpan('file.write', {
    'file.path': path,
    'file.size': content.length,
  });
  
  try {
    await fs.promises.writeFile(path, content);
  } finally {
    endSpan(span);
  }
}
```

### 7. Semantic conventions for spans

Use consistent attribute naming following OpenTelemetry semantic conventions where applicable:

| Span Name | Key Attributes |
|-----------|----------------|
| `cli.execute` | `cli.command`, `cli.args`, `cli.cwd`, `cli.version`, `cli.exit_code` |
| `cli.parse` | `cli.command`, `cli.subcommand`, `cli.flags` |
| `file.read` | `file.path`, `file.size`, `file.exists` |
| `file.write` | `file.path`, `file.size`, `file.created` |
| `schema.validate` | `schema.path`, `schema.valid`, `schema.error_count` |
| `model.load` | `model.path`, `model.type`, `model.entity_count` |

## Acceptance Criteria

- [ ] Production builds (`npm run build`) contain zero telemetry codeâ€”verify by searching bundle for "opentelemetry"
- [ ] Debug builds (`DR_TELEMETRY=true npm run build:debug`) include full instrumentation
- [ ] CLI executes normally when Jaeger is not running (graceful degradation)
- [ ] When Jaeger is running, all command executions appear as traces with:
  - Full command line arguments
  - Files read/written with paths and sizes
  - Error details for failed commands
  - Timing for all operations
- [ ] `SimpleSpanProcessor` ensures all spans are exported before CLI exits
- [ ] Docker Compose file for easy local Jaeger setup

## Dependencies to Add

```json
{
  "devDependencies": {
    "@opentelemetry/api": "^1.9.0",
    "@opentelemetry/sdk-node": "^0.57.0",
    "@opentelemetry/sdk-trace-base": "^1.30.0",
    "@opentelemetry/exporter-trace-otlp-http": "^0.57.0"
  }
}
```

Note: These should be `devDependencies` since they're only used in debug builds.
**Labels**: [{'id': 'LA_kwDOQaznN88AAAACQehUFA', 'name': 'enhancement', 'description': 'New feature or request', 'color': 'a2eeef'}]

## Previous Stage Output
## Output from Business Analyst

# Business Analysis

---

## Executive Summary

This requirement introduces OpenTelemetry-based observability instrumentation for the Documentation Robotics CLI to enable debugging during Claude Code agent interactions. The implementation must be conditionally compiledâ€”fully present in debug builds and completely eliminated from production buildsâ€”using build-time constants and dead code elimination. The telemetry captures command execution, file operations, validation steps, and errors, exporting to a local Jaeger instance while gracefully degrading when the collector is unavailable.

**Core Business Value**: Enable developers to diagnose Claude Code agent usage patterns and distinguish between agent misuse and CLI bugs without impacting production performance or bundle size.

**Scope**: Bun CLI (`cli-bun/`) onlyâ€”instrumentation points in CLI entry, file I/O, schema validation, and model operations.

## Functional Requirements

### FR1: Build-Time Telemetry Toggle
- **FR1.1**: Production builds (`npm run build`) must contain zero OpenTelemetry code or imports
- **FR1.2**: Debug builds (`DR_TELEMETRY=true npm run build:debug`) must include full OpenTelemetry instrumentation
- **FR1.3**: Build configuration must use esbuild's `define` option to inject `TELEMETRY_ENABLED` constant
- **FR1.4**: Build configuration must enable `minifySyntax` for dead branch elimination
- **FR1.5**: TypeScript must declare `TELEMETRY_ENABLED` as global boolean constant

### FR2: Telemetry SDK Initialization
- **FR2.1**: When `TELEMETRY_ENABLED` is true, initialize OpenTelemetry NodeSDK with service name "dr-cli"
- **FR2.2**: Use `SimpleSpanProcessor` to ensure all spans are exported before CLI process exits
- **FR2.3**: Configure OTLP HTTP exporter targeting `http://localhost:4318/v1/traces` by default
- **FR2.4**: Allow override via `OTEL_EXPORTER_OTLP_ENDPOINT` environment variable
- **FR2.5**: Shutdown SDK gracefully on CLI exit, ignoring shutdown failures

### FR3: Graceful Degradation
- **FR3.1**: CLI must execute normally when Jaeger collector is not running
- **FR3.2**: Failed exports must not block CLI execution or produce visible errors
- **FR3.3**: Exporter must implement 30-second backoff after first connection failure
- **FR3.4**: During backoff period, spans must be silently discarded
- **FR3.5**: Exporter timeout must be 500ms maximum for local development scenarios

### FR4: CLI Execution Instrumentation
- **FR4.1**: Create root span `cli.execute` capturing:
  - `cli.command`: First positional argument (e.g., "validate")
  - `cli.args`: Remaining arguments as space-separated string
  - `cli.cwd`: Current working directory
  - `cli.version`: CLI version from package.json
  - `cli.exit_code`: Process exit code (if non-zero)
- **FR4.2**: Set span status to `OK` on successful execution
- **FR4.3**: Set span status to `ERROR` on exception with error message
- **FR4.4**: Record full exception details using `recordException()`

### FR5: File Operation Instrumentation
- **FR5.1**: Instrument file read operations with span `file.read` capturing:
  - `file.path`: Absolute or relative file path
  - `file.size`: File size in bytes
  - `file.exists`: Boolean indicating if file was found
- **FR5.2**: Instrument file write operations with span `file.write` capturing:
  - `file.path`: Absolute or relative file path
  - `file.size`: Content size in bytes
  - `file.created`: Boolean indicating if file was newly created

### FR6: Validation Instrumentation
- **FR6.1**: Instrument schema validation with span `schema.validate` capturing:
  - `schema.path`: Path to schema file
  - `schema.valid`: Boolean validation result
  - `schema.error_count`: Number of validation errors
- **FR6.2**: Instrument model loading with span `model.load` capturing:
  - `model.path`: Path to model directory
  - `model.type`: Model format (e.g., "dr-native")
  - `model.entity_count`: Number of entities loaded

### FR7: Local Development Setup
- **FR7.1**: Provide Docker Compose configuration for Jaeger all-in-one image
- **FR7.2**: Expose Jaeger UI on port 16686
- **FR7.3**: Expose OTLP HTTP endpoint on port 4318
- **FR7.4**: Enable OTLP collector in Jaeger configuration
- **FR7.5**: Docker Compose file must be located in `docker/docker-compose.telemetry.yml`

### FR8: Semantic Conventions
- **FR8.1**: All span names must follow pattern `{domain}.{operation}` (e.g., `cli.execute`, `file.read`)
- **FR8.2**: Attribute names must follow OpenTelemetry semantic conventions where applicable
- **FR8.3**: Custom attributes must use namespaced naming (e.g., `cli.*`, `file.*`, `schema.*`)

### FR9: Tree-Shaking Compatibility
- **FR9.1**: OpenTelemetry imports must use dynamic `require()` inside `TELEMETRY_ENABLED` guards
- **FR9.2**: All telemetry function calls must be directly guarded by `if (TELEMETRY_ENABLED)` checks
- **FR9.3**: No intermediate variables storing `TELEMETRY_ENABLED` value (prevents optimization)
- **FR9.4**: Telemetry module exports must return null/no-op values when disabled

## User Stories

### US1: Zero Production Overhead
**As a** CLI user  
**I want** production builds to contain no telemetry code  
**So that** the CLI remains fast and lightweight for normal usage

**Acceptance Criteria:**
- Given I run `npm run build`
- When I search the generated bundle for "opentelemetry"
- Then zero matches are found
- And the bundle size is not increased by telemetry dependencies
- And execution performance is identical to pre-telemetry builds

### US2: Debug Build Instrumentation
**As a** CLI developer  
**I want** debug builds to include full OpenTelemetry instrumentation  
**So that** I can observe Claude Code agent interactions during development

**Acceptance Criteria:**
- Given I run `DR_TELEMETRY=true npm run build:debug`
- When I execute `node dist/cli.js validate --help`
- Then a span named `cli.execute` is created
- And the span includes `cli.command=validate` and `cli.args=--help`
- And the span is exported to the configured OTLP endpoint

### US3: Graceful Failure Without Collector
**As a** CLI developer  
**I want** the CLI to work normally when Jaeger is not running  
**So that** I don't need to always run the collector during development

**Acceptance Criteria:**
- Given Jaeger is not running
- When I execute any `dr` command in a debug build
- Then the command executes successfully
- And no error messages about telemetry appear
- And the CLI exit code is unchanged from expected behavior

### US4: Command Execution Tracing
**As a** CLI developer  
**I want** all command executions to appear as traces in Jaeger  
**So that** I can see the full execution timeline and context

**Acceptance Criteria:**
- Given Jaeger is running at `http://localhost:4318`
- When I execute `dr validate --layer api`
- Then Jaeger UI shows a trace for service "dr-cli"
- And the trace contains a root span with command details
- And child spans show file operations and validation steps
- And all spans have end timestamps before CLI process exits

### US5: File Operation Visibility
**As a** CLI developer  
**I want** file reads and writes to be captured as spans  
**So that** I can see which files Claude Code agents are accessing

**Acceptance Criteria:**
- Given a debug build with Jaeger running
- When I execute `dr add business service test-service --name "Test"`
- Then the trace shows `file.write` spans for created/modified files
- And each span includes `file.path` and `file.size` attributes
- And file paths are accurate relative or absolute paths

### US6: Error Diagnostics
**As a** CLI developer  
**I want** errors to be captured with full details in spans  
**So that** I can diagnose failures from agent interactions

**Acceptance Criteria:**
- Given a debug build with Jaeger running
- When I execute a command that throws an error (e.g., invalid schema)
- Then the root span has status `ERROR`
- And the span includes the error message
- And the span includes exception stack trace via `recordException()`
- And the trace is exported before CLI process exits

### US7: Easy Local Setup
**As a** CLI developer  
**I want** a simple Docker Compose file for Jaeger  
**So that** I can quickly start collecting telemetry

**Acceptance Criteria:**
- Given the repository contains `docker/docker-compose.telemetry.yml`
- When I run `docker compose -f docker/docker-compose.telemetry.yml up -d`
- Then Jaeger starts with OTLP HTTP endpoint on port 4318
- And Jaeger UI is accessible at `http://localhost:16686`
- And the CLI can successfully export spans to this endpoint

### US8: Schema Validation Tracing
**As a** CLI developer  
**I want** schema validation operations to be traced  
**So that** I can see validation performance and error patterns

**Acceptance Criteria:**
- Given a debug build with Jaeger running
- When I execute `dr validate` on a model
- Then the trace shows `schema.validate` spans for each validated file
- And spans include `schema.path`, `schema.valid`, and `schema.error_count`
- And invalid schemas have error details in span attributes

---
_Generated by Orchestrator Bot ðŸ¤–_
_Processed by the business_analyst agent_

Build upon this previous analysis in your work.

## Quality Standards

- Architecture patterns are appropriate for the problem domain and the application
- Scalability considerations are clearly defined
- Security best practices are incorporated
- Technology choices are justified with ADRs
- Design supports maintainability and testability
- No unnecessary complexity is introduced
- No over-engineering is present
- No new design patterns that are not important to the project


## Output Format

Provide a comprehensive analysis with the following sections:
- System Architecture
- Scalability Design
- Established Patterns
- Component Reuse
- Implementation Plan



**IMPORTANT - OUTPUT FORMAT FOR ANALYSIS**:
- **PROJECT-SPECIFIC CONVENTIONS OVERRIDE**: Read `/workspace/CLAUDE.md` first. The project's CLAUDE.md file defines project-specific conventions and documentation requirements that take precedence over these general instructions.
- Output your analysis as markdown text directly in your response
- DO NOT create any files - this will be posted to GitHub as a comment
- DO NOT include project name, feature name, or date headers (this info is already in the discussion)
- **START IMMEDIATELY** with your first section heading (e.g., "## Executive Summary" or "## Problem Abstraction")
- **NO CONVERSATIONAL PREAMBLES**: Do NOT include statements like "Ok, I'll build...", "I'll analyze...", "Let me create...", etc.
- **NO SUMMARY SECTIONS**: Do NOT create a "Summary for GitHub Comment" section at the end - your entire output IS the comment
- **NO INTERNAL DIALOG**: Do NOT include planning statements like "Let me research...", "I'll examine...", "Now let me check..."
- **NO TOOL USAGE COMMENTARY**: Do not narrate what tools you're using or what you're searching for
- Focus on WHAT needs to be done, not HOW or WHEN
- Be specific and factual, avoid hypotheticals and hyperbole
- Use proper markdown formatting (headers, lists, code blocks)

