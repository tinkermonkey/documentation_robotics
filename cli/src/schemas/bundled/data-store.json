{
  "specVersion": "0.8.0",
  "layer": {
    "id": "data-store",
    "number": 8,
    "name": "Data Store Layer",
    "description": "Layer 8: Data Store Layer",
    "inspired_by": {
      "standard": "ISO/IEC 9075 (SQL) + Paradigm Extensions",
      "version": "2024",
      "url": "https://en.wikipedia.org/wiki/Database_model"
    },
    "node_types": [
      "data-store.accesspattern",
      "data-store.collection",
      "data-store.database",
      "data-store.eventhandler",
      "data-store.field",
      "data-store.index",
      "data-store.namespace",
      "data-store.retentionpolicy",
      "data-store.storedlogic",
      "data-store.validationrule",
      "data-store.view"
    ]
  },
  "nodeSchemas": {
    "accesspattern": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "AccessPattern",
      "description": "A documented data access pattern that describes how applications read or write data. Critical for NoSQL data modeling where schema design is driven by access patterns rather than normalization.",
      "allOf": [
        {
          "$ref": "urn:dr:spec:base:spec-node"
        }
      ],
      "properties": {
        "spec_node_id": {
          "const": "data-store.accesspattern"
        },
        "layer_id": {
          "const": "data-store"
        },
        "type": {
          "const": "accesspattern"
        },
        "attributes": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "format": "uuid"
            },
            "name": {
              "type": "string"
            },
            "patternType": {
              "type": "string",
              "enum": [
                "POINT_READ",
                "RANGE_SCAN",
                "FULL_SCAN",
                "WRITE",
                "UPSERT",
                "BATCH_WRITE",
                "AGGREGATION",
                "SEARCH",
                "VECTOR_SIMILARITY",
                "GRAPH_TRAVERSAL",
                "TIME_RANGE",
                "LATEST_VALUE",
                "CUSTOM"
              ],
              "description": "Category of access pattern. POINT_READ: single-record lookup by key. RANGE_SCAN: ordered range of records. FULL_SCAN: all records. WRITE/UPSERT/BATCH_WRITE: mutation patterns. AGGREGATION: computed result over records. SEARCH: full-text or filtered search. VECTOR_SIMILARITY: approximate nearest neighbor. GRAPH_TRAVERSAL: multi-hop graph walk. TIME_RANGE/LATEST_VALUE: time-series queries."
            },
            "targetCollection": {
              "type": "string",
              "description": "The collection this access pattern operates on."
            },
            "keyCondition": {
              "type": "string",
              "description": "Key or partition condition for this access (e.g., 'customer_id = :id', 'PK = USER#:userId AND SK BEGINS_WITH ORDER#')."
            },
            "sortKey": {
              "type": "string",
              "description": "Sort key expression for composite key patterns (e.g., 'SK BEGINS_WITH ORDER#', 'timestamp BETWEEN :start AND :end'). Used in DynamoDB/Cassandra to define the clustering dimension of the access pattern."
            },
            "filterCondition": {
              "type": "string",
              "description": "Additional filter condition applied after key lookup."
            },
            "expectedFrequency": {
              "type": "string",
              "enum": ["RARE", "OCCASIONAL", "FREQUENT", "HIGH_THROUGHPUT", "REAL_TIME"],
              "description": "Expected frequency of this access pattern. Informs capacity planning and index decisions."
            },
            "consistencyRequirement": {
              "type": "string",
              "enum": ["STRONG", "EVENTUAL", "SESSION", "CAUSAL", "LINEARIZABLE"],
              "description": "Required consistency level for this access pattern."
            },
            "x-source-reference": {
              "type": "string",
              "description": "Source code reference using OpenAPI x- extension pattern."
            }
          },
          "required": ["patternType", "targetCollection"],
          "additionalProperties": false
        }
      },
      "$id": "urn:dr:spec:node:data-store.accesspattern"
    },
    "collection": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Collection",
      "description": "A container for records, documents, or entries within a data store. Paradigm-neutral: maps to SQL table, document store collection, key-value bucket/hash, wide-column table/column family, vector collection, time-series measurement/hypertable, graph node label or edge type, and search engine index.",
      "allOf": [
        {
          "$ref": "urn:dr:spec:base:spec-node"
        }
      ],
      "properties": {
        "spec_node_id": {
          "const": "data-store.collection"
        },
        "layer_id": {
          "const": "data-store"
        },
        "type": {
          "const": "collection"
        },
        "attributes": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "format": "uuid"
            },
            "name": {
              "type": "string"
            },
            "collectionType": {
              "type": "string",
              "enum": [
                "TABLE",
                "COLLECTION",
                "COLUMN_FAMILY",
                "BUCKET",
                "HASH",
                "SORTED_SET",
                "STREAM",
                "VECTOR_COLLECTION",
                "MEASUREMENT",
                "HYPERTABLE",
                "NODE_LABEL",
                "EDGE_TYPE",
                "SEARCH_INDEX"
              ],
              "description": "The paradigm-specific type of this collection. TABLE: relational table. COLLECTION: document store collection. COLUMN_FAMILY: wide-column column family. BUCKET/HASH/SORTED_SET/STREAM: key-value data structures. VECTOR_COLLECTION: vector embedding store. MEASUREMENT/HYPERTABLE: time-series data container. NODE_LABEL/EDGE_TYPE: graph database structural types. SEARCH_INDEX: search engine index."
            },
            "partitionKey": {
              "type": "string",
              "description": "Primary partition key field name(s). Used by wide-column stores (Cassandra partition key), DynamoDB (partition key), time-series (time field), and sharded relational databases."
            },
            "clusteringKeys": {
              "type": "string",
              "description": "Clustering or sort key field name(s) that determine ordering within a partition. Relevant for wide-column stores (Cassandra clustering columns) and DynamoDB sort keys."
            },
            "ttlDefault": {
              "type": "integer",
              "description": "Default time-to-live in seconds for entries in this collection. Relevant for key-value stores, wide-column stores, and time-series databases."
            },
            "validationSchema": {
              "type": "string",
              "description": "Reference to a schema definition that validates documents or records. For MongoDB this is the JSON Schema validator; for relational databases, the set of column constraints; for search engines, the mapping definition."
            },
            "fields": {
              "type": "array",
              "description": "Contains relationship to fields within this collection"
            },
            "constraints": {
              "type": "array",
              "description": "Contains relationship to validation rules on this collection"
            },
            "indexes": {
              "type": "array",
              "description": "Contains relationship to indexes on this collection"
            },
            "eventHandlers": {
              "type": "array",
              "description": "Contains relationship to event handlers (triggers, change streams) on this collection"
            },
            "x-source-reference": {
              "type": "string",
              "description": "Source code reference using OpenAPI x- extension pattern."
            }
          },
          "additionalProperties": false
        }
      },
      "$id": "urn:dr:spec:node:data-store.collection"
    },
    "database": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Database",
      "description": "A database instance representing a top-level data store deployment. Paradigm-neutral: covers relational databases, document stores, key-value stores, wide-column stores, vector databases, time-series databases, graph databases, search engines, and multi-model systems.",
      "allOf": [
        {
          "$ref": "urn:dr:spec:base:spec-node"
        }
      ],
      "properties": {
        "spec_node_id": {
          "const": "data-store.database"
        },
        "layer_id": {
          "const": "data-store"
        },
        "type": {
          "const": "database"
        },
        "attributes": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "format": "uuid"
            },
            "name": {
              "type": "string"
            },
            "engine": {
              "type": "string",
              "description": "Database engine name (e.g., 'PostgreSQL', 'MongoDB', 'Redis', 'Cassandra', 'Pinecone', 'Neo4j', 'Elasticsearch', 'InfluxDB', 'DynamoDB'). Free-text to accommodate any engine without enumeration constraints."
            },
            "paradigm": {
              "type": "string",
              "enum": [
                "RELATIONAL",
                "DOCUMENT",
                "KEY_VALUE",
                "WIDE_COLUMN",
                "VECTOR",
                "TIME_SERIES",
                "GRAPH",
                "SEARCH_ENGINE",
                "MULTI_MODEL"
              ],
              "description": "Primary data model paradigm. RELATIONAL: SQL-based tabular data (PostgreSQL, MySQL, Oracle). DOCUMENT: JSON/BSON document storage (MongoDB, CouchDB, Firestore). KEY_VALUE: simple key-to-value mapping (Redis, DynamoDB, etcd). WIDE_COLUMN: column-family storage (Cassandra, HBase, Bigtable). VECTOR: vector embedding storage and similarity search (Pinecone, Weaviate, Qdrant). TIME_SERIES: time-indexed measurements (InfluxDB, TimescaleDB). GRAPH: nodes and edges with traversal (Neo4j, Neptune). SEARCH_ENGINE: full-text search and analytics (Elasticsearch, OpenSearch). MULTI_MODEL: natively supports multiple paradigms (ArangoDB, CosmosDB, FaunaDB)."
            },
            "version": {
              "type": "string"
            },
            "charset": {
              "type": "string"
            },
            "collation": {
              "type": "string"
            },
            "deploymentModel": {
              "type": "string",
              "enum": [
                "STANDALONE",
                "REPLICATED",
                "SHARDED",
                "DISTRIBUTED",
                "SERVERLESS",
                "EMBEDDED"
              ],
              "description": "How the database is deployed. STANDALONE: single instance. REPLICATED: primary with read replicas. SHARDED: data partitioned across nodes. DISTRIBUTED: fully distributed with no single primary. SERVERLESS: cloud-managed auto-scaling. EMBEDDED: in-process database (SQLite, RocksDB)."
            },
            "namespaces": {
              "type": "array",
              "description": "Contains relationship to namespaces within this database"
            }
          },
          "required": ["engine", "paradigm"],
          "additionalProperties": false
        }
      },
      "$id": "urn:dr:spec:node:data-store.database"
    },
    "eventhandler": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "EventHandler",
      "description": "A reactive mechanism that executes in response to data change events. Paradigm-neutral: covers SQL triggers, MongoDB change streams, DynamoDB Streams, Cassandra CDC, Redis keyspace notifications, Elasticsearch watchers, Neo4j APOC triggers, and time-series alerting rules.",
      "allOf": [
        {
          "$ref": "urn:dr:spec:base:spec-node"
        }
      ],
      "properties": {
        "spec_node_id": {
          "const": "data-store.eventhandler"
        },
        "layer_id": {
          "const": "data-store"
        },
        "type": {
          "const": "eventhandler"
        },
        "attributes": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "format": "uuid"
            },
            "name": {
              "type": "string"
            },
            "handlerType": {
              "type": "string",
              "enum": [
                "TRIGGER",
                "CHANGE_STREAM",
                "CDC_LISTENER",
                "KEYSPACE_NOTIFICATION",
                "STREAM_PROCESSOR",
                "WATCHER",
                "ALERT_RULE",
                "CUSTOM"
              ],
              "description": "Type of event handler mechanism. TRIGGER: synchronous SQL trigger (BEFORE/AFTER DML). CHANGE_STREAM: asynchronous document change feed (MongoDB, CouchDB). CDC_LISTENER: change data capture consumer (Cassandra, Debezium). KEYSPACE_NOTIFICATION: key event notification (Redis). STREAM_PROCESSOR: stream-based event processor (Redis Streams, Kafka Connect). WATCHER: periodic condition check and alert (Elasticsearch). ALERT_RULE: threshold or anomaly alerting (time-series, monitoring). CUSTOM: engine-specific mechanism not listed."
            },
            "targetCollection": {
              "type": "string",
              "description": "The collection or database-level scope this handler is attached to."
            },
            "timing": {
              "type": "string",
              "enum": ["BEFORE", "AFTER", "INSTEAD_OF", "ON_CHANGE", "CONTINUOUS"],
              "description": "When the handler fires relative to the event. BEFORE: fires before the operation (SQL BEFORE trigger). AFTER: fires after the operation (SQL AFTER trigger). INSTEAD_OF: replaces the operation (SQL INSTEAD OF trigger for views). ON_CHANGE: fires when a change is detected (change streams, CDC). CONTINUOUS: always-on stream processing."
            },
            "events": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "INSERT",
                  "UPDATE",
                  "DELETE",
                  "REPLACE",
                  "TRUNCATE",
                  "DROP",
                  "INVALIDATE",
                  "EXPIRE",
                  "SET",
                  "DEL",
                  "THRESHOLD",
                  "ANOMALY",
                  "CUSTOM"
                ]
              },
              "description": "Events that activate this handler. SQL: INSERT/UPDATE/DELETE/TRUNCATE. Document: INSERT/UPDATE/DELETE/REPLACE/DROP/INVALIDATE. Key-value: EXPIRE/SET/DEL. Monitoring: THRESHOLD/ANOMALY. CUSTOM: engine-specific event not listed."
            },
            "granularity": {
              "type": "string",
              "enum": ["ROW", "STATEMENT", "DOCUMENT", "KEY", "BATCH"],
              "description": "Granularity of handler activation. ROW: fires once per affected row (SQL FOR EACH ROW). STATEMENT: fires once per SQL statement. DOCUMENT: fires per changed document (document store change streams). KEY: fires per key operation (key-value notifications). BATCH: fires per batch of changes (CDC, stream processing)."
            },
            "action": {
              "type": "string",
              "description": "Reference to the stored logic (function name, pipeline reference, or inline expression) that executes when this handler fires."
            },
            "condition": {
              "type": "string",
              "description": "Optional filter condition. Only events matching this condition activate the handler. Maps to SQL WHEN clause, MongoDB pipeline $match stage, or Elasticsearch watcher condition."
            },
            "enabled": {
              "type": "boolean"
            }
          },
          "required": ["handlerType", "events"],
          "additionalProperties": false
        }
      },
      "$id": "urn:dr:spec:node:data-store.eventhandler"
    },
    "field": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Field",
      "description": "A named data element within a collection. Paradigm-neutral: maps to SQL column, document store field/path, key-value hash field, wide-column column, vector dimension or metadata field, time-series tag or field, graph property, and search engine mapping property.",
      "allOf": [
        {
          "$ref": "urn:dr:spec:base:spec-node"
        }
      ],
      "properties": {
        "spec_node_id": {
          "const": "data-store.field"
        },
        "layer_id": {
          "const": "data-store"
        },
        "type": {
          "const": "field"
        },
        "attributes": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "format": "uuid"
            },
            "name": {
              "type": "string"
            },
            "dataType": {
              "type": "string",
              "description": "Data type of this field. Interpretation is paradigm-specific: SQL types (VARCHAR, INTEGER, TIMESTAMP), BSON types (String, ObjectId, Document), Elasticsearch mapping types (keyword, text, dense_vector), or any engine-native type name."
            },
            "nullable": {
              "type": "boolean"
            },
            "defaultValue": {
              "type": "string"
            },
            "generated": {
              "type": "string",
              "enum": ["ALWAYS", "BY_DEFAULT", "NEVER"],
              "description": "Whether the field value is auto-generated. ALWAYS: value is always system-generated (SQL identity GENERATED ALWAYS, MongoDB auto _id, auto-increment). BY_DEFAULT: system-generated unless explicitly overridden (SQL GENERATED BY DEFAULT). NEVER: value must be user-provided."
            },
            "fieldRole": {
              "type": "string",
              "enum": [
                "VALUE",
                "TAG",
                "TIMESTAMP",
                "PARTITION_KEY",
                "CLUSTERING_KEY",
                "VECTOR",
                "METADATA",
                "LABEL",
                "PROPERTY"
              ],
              "description": "Semantic role of this field within its collection. VALUE: regular data field. TAG: indexed metadata for filtering (time-series). TIMESTAMP: time-series time field. PARTITION_KEY: wide-column or distributed partition key component. CLUSTERING_KEY: wide-column clustering/sort key component. VECTOR: vector embedding field. METADATA: vector store metadata for filtering. LABEL: graph node label. PROPERTY: graph node or edge property."
            },
            "vectorDimensions": {
              "type": "integer",
              "description": "Number of dimensions for vector fields. Only applicable when fieldRole is VECTOR."
            },
            "distanceMetric": {
              "type": "string",
              "enum": ["COSINE", "EUCLIDEAN", "DOT_PRODUCT", "MANHATTAN"],
              "description": "Distance metric for vector similarity search. COSINE: angular similarity. EUCLIDEAN: L2 distance. DOT_PRODUCT: inner product similarity. MANHATTAN: L1 distance. Only applicable when fieldRole is VECTOR."
            },
            "analyzer": {
              "type": "string",
              "description": "Text analyzer for search engine fields (e.g., 'standard', 'english', 'keyword', 'whitespace'). Controls tokenization and normalization. Only applicable for search engine paradigm."
            },
            "nested": {
              "type": "boolean",
              "description": "Whether this field contains nested or embedded documents. Relevant for document stores (MongoDB embedded documents) and search engines (Elasticsearch nested type)."
            },
            "x-source-reference": {
              "type": "string",
              "description": "Source code reference using OpenAPI x- extension pattern."
            }
          },
          "required": ["dataType"],
          "additionalProperties": false
        }
      },
      "$id": "urn:dr:spec:node:data-store.field"
    },
    "index": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Index",
      "description": "A database index for query optimization. Paradigm-neutral: covers B-tree and hash indexes (relational), compound and multikey indexes (document stores), vector approximate nearest neighbor indexes (HNSW, IVF), inverted indexes (search engines), geospatial indexes, and secondary indexes (wide-column stores).",
      "allOf": [
        {
          "$ref": "urn:dr:spec:base:spec-node"
        }
      ],
      "properties": {
        "spec_node_id": {
          "const": "data-store.index"
        },
        "layer_id": {
          "const": "data-store"
        },
        "type": {
          "const": "index"
        },
        "attributes": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "format": "uuid"
            },
            "name": {
              "type": "string"
            },
            "fields": {
              "type": "string",
              "description": "Field name(s) included in the index key."
            },
            "unique": {
              "type": "boolean"
            },
            "method": {
              "type": "string",
              "enum": [
                "BTREE",
                "HASH",
                "GIN",
                "GIST",
                "SPGIST",
                "BRIN",
                "HNSW",
                "IVF_FLAT",
                "IVF_PQ",
                "ANNOY",
                "LSH",
                "INVERTED",
                "FULLTEXT",
                "GEOSPATIAL",
                "COMPOUND",
                "MULTIKEY",
                "CUSTOM"
              ],
              "description": "Index access method. BTREE/HASH: traditional ordered and hash-based (relational, document). GIN/GIST/SPGIST/BRIN: PostgreSQL advanced index types. HNSW/IVF_FLAT/IVF_PQ/ANNOY/LSH: vector approximate nearest neighbor algorithms. INVERTED/FULLTEXT: search engine and full-text indexes. GEOSPATIAL: location-based spatial indexes. COMPOUND/MULTIKEY: document store compound and array indexes. CUSTOM: engine-specific method not listed."
            },
            "where": {
              "type": "string",
              "description": "Partial or filtered index predicate. Only entries satisfying this condition are indexed. Supported by relational (PostgreSQL, SQL Server) and document stores (MongoDB partial index filter)."
            },
            "include": {
              "type": "string",
              "description": "Covering index: additional fields stored in the index but not in the search key. Reduces lookups by including frequently accessed fields in the index leaf pages."
            },
            "sparse": {
              "type": "boolean",
              "description": "Whether the index only includes entries where the indexed field exists. Relevant for document stores with flexible schemas and sparse datasets."
            },
            "vectorConfig": {
              "type": "object",
              "description": "Configuration parameters for vector indexes. Only applicable when method is HNSW, IVF_FLAT, IVF_PQ, ANNOY, or LSH.",
              "properties": {
                "dimensions": {
                  "type": "integer",
                  "description": "Number of dimensions in the vector space."
                },
                "distanceMetric": {
                  "type": "string",
                  "enum": ["COSINE", "EUCLIDEAN", "DOT_PRODUCT", "MANHATTAN"],
                  "description": "Distance metric for similarity computation."
                },
                "efConstruction": {
                  "type": "integer",
                  "description": "HNSW build-time parameter controlling index quality vs. build speed tradeoff."
                },
                "m": {
                  "type": "integer",
                  "description": "HNSW maximum number of connections per node in the graph."
                },
                "nlist": {
                  "type": "integer",
                  "description": "IVF number of clusters (Voronoi cells) for partitioning the vector space."
                }
              },
              "additionalProperties": true
            }
          },
          "additionalProperties": false
        }
      },
      "$id": "urn:dr:spec:node:data-store.index"
    },
    "namespace": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Namespace",
      "description": "A logical grouping of database objects within a database instance. Paradigm-neutral: maps to SQL schema, MongoDB database, Cassandra keyspace, Redis namespace/prefix, Elasticsearch index, vector database namespace, and graph database named graph.",
      "allOf": [
        {
          "$ref": "urn:dr:spec:base:spec-node"
        }
      ],
      "properties": {
        "spec_node_id": {
          "const": "data-store.namespace"
        },
        "layer_id": {
          "const": "data-store"
        },
        "type": {
          "const": "namespace"
        },
        "attributes": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "format": "uuid"
            },
            "name": {
              "type": "string"
            },
            "owner": {
              "type": "string"
            },
            "collections": {
              "type": "array",
              "description": "Contains relationship to collections within this namespace"
            },
            "storedLogic": {
              "type": "array",
              "description": "Contains relationship to stored logic (functions, procedures, pipelines) within this namespace"
            }
          },
          "additionalProperties": false
        }
      },
      "$id": "urn:dr:spec:node:data-store.namespace"
    },
    "retentionpolicy": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "RetentionPolicy",
      "description": "A data lifecycle management policy that governs how long data is retained and what action is taken when the retention period expires. Applicable across paradigms: time-series downsampling, key-value TTL, search index lifecycle, relational partition pruning, and archival strategies.",
      "allOf": [
        {
          "$ref": "urn:dr:spec:base:spec-node"
        }
      ],
      "properties": {
        "spec_node_id": {
          "const": "data-store.retentionpolicy"
        },
        "layer_id": {
          "const": "data-store"
        },
        "type": {
          "const": "retentionpolicy"
        },
        "attributes": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "format": "uuid"
            },
            "name": {
              "type": "string"
            },
            "targetCollection": {
              "type": "string",
              "description": "The collection or namespace this policy applies to."
            },
            "retentionDuration": {
              "type": "string",
              "description": "How long data is retained, expressed as an ISO 8601 duration (e.g., 'P30D' for 30 days, 'P1Y' for 1 year, 'P6M' for 6 months)."
            },
            "action": {
              "type": "string",
              "enum": ["DELETE", "ARCHIVE", "DOWNSAMPLE", "MOVE_TIER", "COMPRESS"],
              "description": "Action taken when data exceeds the retention period. DELETE: permanently remove. ARCHIVE: move to cold storage. DOWNSAMPLE: aggregate and reduce resolution (time-series). MOVE_TIER: transition to a different storage tier. COMPRESS: apply compression to reduce storage footprint."
            },
            "downsampleInterval": {
              "type": "string",
              "description": "For DOWNSAMPLE action, the aggregation interval (e.g., '1h', '1d'). Only applicable when action is DOWNSAMPLE."
            },
            "enabled": {
              "type": "boolean"
            }
          },
          "required": ["targetCollection", "retentionDuration", "action"],
          "additionalProperties": false
        }
      },
      "$id": "urn:dr:spec:node:data-store.retentionpolicy"
    },
    "storedlogic": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "StoredLogic",
      "description": "Stored computation logic that executes within the data store engine. Paradigm-neutral: covers SQL functions and procedures, MongoDB aggregation pipelines, Redis Lua scripts, Cassandra UDFs, Neo4j stored procedures, Elasticsearch ingest pipelines, time-series continuous queries, and DynamoDB Lambda triggers.",
      "allOf": [
        {
          "$ref": "urn:dr:spec:base:spec-node"
        }
      ],
      "properties": {
        "spec_node_id": {
          "const": "data-store.storedlogic"
        },
        "layer_id": {
          "const": "data-store"
        },
        "type": {
          "const": "storedlogic"
        },
        "attributes": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "format": "uuid"
            },
            "name": {
              "type": "string"
            },
            "logicType": {
              "type": "string",
              "enum": [
                "FUNCTION",
                "PROCEDURE",
                "PACKAGE",
                "AGGREGATION_PIPELINE",
                "MAP_REDUCE",
                "LUA_SCRIPT",
                "LAMBDA",
                "UDF",
                "UDA",
                "CONTINUOUS_QUERY",
                "FLUX_TASK",
                "STORED_PROCEDURE",
                "CYPHER_FUNCTION",
                "INGEST_PIPELINE",
                "PAINLESS_SCRIPT",
                "CUSTOM"
              ],
              "description": "Type of stored computation. FUNCTION/PROCEDURE/PACKAGE: SQL-standard. AGGREGATION_PIPELINE/MAP_REDUCE: document store (MongoDB). LUA_SCRIPT: key-value (Redis). LAMBDA: serverless trigger (DynamoDB Streams). UDF/UDA: user-defined function/aggregate (Cassandra). CONTINUOUS_QUERY/FLUX_TASK: time-series scheduled computation. STORED_PROCEDURE/CYPHER_FUNCTION: graph database. INGEST_PIPELINE/PAINLESS_SCRIPT: search engine. CUSTOM: engine-specific type not listed."
            },
            "language": {
              "type": "string",
              "enum": [
                "SQL",
                "PLPGSQL",
                "PLSQL",
                "TSQL",
                "JAVASCRIPT",
                "PYTHON",
                "LUA",
                "JAVA",
                "C",
                "CYPHER",
                "GREMLIN",
                "SPARQL",
                "FLUX",
                "INFLUXQL",
                "PAINLESS",
                "MVEL",
                "MQL",
                "EXTERNAL",
                "CUSTOM"
              ],
              "description": "Implementation language. SQL/PLPGSQL/PLSQL/TSQL: relational database languages. JAVASCRIPT/PYTHON/LUA/JAVA/C: general-purpose embedded languages. CYPHER/GREMLIN/SPARQL: graph query languages. FLUX/INFLUXQL: time-series query languages. PAINLESS/MVEL: search engine scripting. MQL: MongoDB Query Language. EXTERNAL: logic implemented outside the database. CUSTOM: language not listed."
            },
            "returnType": {
              "type": "string",
              "description": "Return type of the computation. For functions, the return data type. For pipelines, the output document shape. For void procedures, 'VOID'."
            },
            "deterministic": {
              "type": "boolean",
              "description": "Whether the logic always returns the same output for the same input. Generalizes SQL volatility (IMMUTABLE = true, VOLATILE = false) across paradigms. Deterministic logic is a candidate for result caching."
            },
            "sideEffects": {
              "type": "boolean",
              "description": "Whether the logic can modify data. Functions without side effects are safe for parallel execution and caching. Maps to SQL CONTAINS SQL / MODIFIES SQL DATA distinction."
            },
            "security": {
              "type": "string",
              "enum": ["DEFINER", "INVOKER"],
              "description": "Security context for execution. DEFINER: runs with privileges of the creator (SQL SECURITY DEFINER). INVOKER: runs with privileges of the caller (SQL SECURITY INVOKER)."
            },
            "x-source-reference": {
              "type": "string",
              "description": "Source code reference using OpenAPI x- extension pattern."
            }
          },
          "required": ["logicType", "language"],
          "additionalProperties": false
        }
      },
      "$id": "urn:dr:spec:node:data-store.storedlogic"
    },
    "validationrule": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ValidationRule",
      "description": "A data integrity or validation rule enforced by the data store. Paradigm-neutral: covers SQL constraints (PRIMARY KEY, FOREIGN KEY, UNIQUE, CHECK, NOT NULL), document store schema validation and required fields, graph uniqueness and existence constraints, key-value key format rules, and search engine mapping enforcement.",
      "allOf": [
        {
          "$ref": "urn:dr:spec:base:spec-node"
        }
      ],
      "properties": {
        "spec_node_id": {
          "const": "data-store.validationrule"
        },
        "layer_id": {
          "const": "data-store"
        },
        "type": {
          "const": "validationrule"
        },
        "attributes": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "format": "uuid"
            },
            "name": {
              "type": "string"
            },
            "ruleType": {
              "type": "string",
              "enum": [
                "PRIMARY_KEY",
                "FOREIGN_KEY",
                "UNIQUE",
                "CHECK",
                "NOT_NULL",
                "SCHEMA_VALIDATION",
                "REQUIRED_FIELD",
                "KEY_FORMAT",
                "TTL_CONSTRAINT",
                "UNIQUENESS_CONSTRAINT",
                "EXISTENCE_CONSTRAINT",
                "NODE_KEY",
                "DIMENSION_CONSTRAINT",
                "MAPPING_STRICT",
                "CUSTOM"
              ],
              "description": "Type of validation or integrity rule. SQL-standard: PRIMARY_KEY, FOREIGN_KEY, UNIQUE, CHECK, NOT_NULL. Document store: SCHEMA_VALIDATION (JSON Schema validator), REQUIRED_FIELD. Key-value: KEY_FORMAT (key naming pattern), TTL_CONSTRAINT. Graph: UNIQUENESS_CONSTRAINT (unique node label+property), EXISTENCE_CONSTRAINT (required property), NODE_KEY (composite unique identifier). Vector: DIMENSION_CONSTRAINT (vector dimension enforcement). Search engine: MAPPING_STRICT (reject unmapped fields). CUSTOM: engine-specific rule not listed."
            },
            "expression": {
              "type": "string",
              "description": "Constraint expression or validation rule body. For CHECK constraints, the SQL expression. For SCHEMA_VALIDATION, a JSON Schema reference. For KEY_FORMAT, a key naming pattern."
            },
            "targetFields": {
              "type": "string",
              "description": "Field name(s) this rule applies to."
            },
            "referencedCollection": {
              "type": "string",
              "description": "For FOREIGN_KEY or cross-collection references, the target collection name."
            },
            "referencedFields": {
              "type": "string",
              "description": "For FOREIGN_KEY or cross-collection references, the target field name(s) in the referenced collection."
            },
            "onDelete": {
              "type": "string",
              "enum": ["CASCADE", "SET_NULL", "SET_DEFAULT", "RESTRICT", "NO_ACTION"],
              "description": "Referential action on delete. CASCADE: delete dependent entries. SET_NULL: nullify the reference. SET_DEFAULT: reset to default value. RESTRICT: reject if referenced entries exist. NO_ACTION: deferred reject. Applicable to FOREIGN_KEY rules."
            },
            "onUpdate": {
              "type": "string",
              "enum": ["CASCADE", "SET_NULL", "SET_DEFAULT", "RESTRICT", "NO_ACTION"],
              "description": "Referential action on update. Same values as onDelete, applied when the referenced field value is modified. Applicable to FOREIGN_KEY rules."
            },
            "enforcement": {
              "type": "string",
              "enum": ["STRICT", "WARN", "LOG"],
              "description": "How the rule is enforced. STRICT: reject violating operations (default for most SQL constraints). WARN: allow but emit a warning (supported by some document store validators). LOG: allow and log the violation for audit purposes."
            }
          },
          "required": ["ruleType"],
          "additionalProperties": false
        }
      },
      "$id": "urn:dr:spec:node:data-store.validationrule"
    },
    "view": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "View",
      "description": "A derived or virtual collection that presents data from one or more source collections. Paradigm-neutral: covers SQL views and materialized views, search engine aliases, document store views (CouchDB), time-series continuous aggregates (TimescaleDB), and named graph projections.",
      "allOf": [
        {
          "$ref": "urn:dr:spec:base:spec-node"
        }
      ],
      "properties": {
        "spec_node_id": {
          "const": "data-store.view"
        },
        "layer_id": {
          "const": "data-store"
        },
        "type": {
          "const": "view"
        },
        "attributes": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "format": "uuid"
            },
            "name": {
              "type": "string"
            },
            "definition": {
              "type": "string",
              "description": "Query or expression that defines this view. SQL query for relational, aggregation pipeline for document stores, alias definition for search engines, continuous aggregate query for time-series, Cypher projection for graph databases."
            },
            "materialized": {
              "type": "boolean",
              "description": "Whether the view data is precomputed and stored rather than computed on each read."
            },
            "viewType": {
              "type": "string",
              "enum": ["VIRTUAL", "MATERIALIZED", "ALIAS", "CONTINUOUS_AGGREGATE", "FILTERED"],
              "description": "Type of view. VIRTUAL: computed on every read (SQL view, CouchDB view). MATERIALIZED: precomputed and stored (SQL materialized view, Cassandra materialized view). ALIAS: pointer or routing abstraction over one or more collections (Elasticsearch alias). CONTINUOUS_AGGREGATE: incrementally maintained materialization (TimescaleDB continuous aggregate, InfluxDB continuous query). FILTERED: read-only subset of another collection."
            },
            "refreshPolicy": {
              "type": "string",
              "enum": ["ON_DEMAND", "ON_COMMIT", "PERIODIC", "CONTINUOUS"],
              "description": "How materialized data is refreshed. ON_DEMAND: manual refresh required. ON_COMMIT: refreshed after each transaction commit. PERIODIC: refreshed on a schedule. CONTINUOUS: incrementally updated as source data changes. Only applicable when materialized is true or viewType is MATERIALIZED or CONTINUOUS_AGGREGATE."
            }
          },
          "additionalProperties": false
        }
      },
      "$id": "urn:dr:spec:node:data-store.view"
    }
  },
  "relationshipSchemas": {
    "data-store.accesspattern.accesses.data-store.collection": {
      "id": "data-store.accesspattern.accesses.data-store.collection",
      "source_spec_node_id": "data-store.accesspattern",
      "source_layer": "data-store",
      "destination_spec_node_id": "data-store.collection",
      "destination_layer": "data-store",
      "predicate": "accesses",
      "cardinality": "many-to-one",
      "strength": "medium",
      "required": false
    },
    "data-store.accesspattern.aggregates.data-store.collection": {
      "id": "data-store.accesspattern.aggregates.data-store.collection",
      "source_spec_node_id": "data-store.accesspattern",
      "source_layer": "data-store",
      "destination_spec_node_id": "data-store.collection",
      "destination_layer": "data-store",
      "predicate": "aggregates",
      "cardinality": "many-to-one",
      "strength": "medium",
      "required": false
    },
    "data-store.accesspattern.aggregates.data-store.field": {
      "id": "data-store.accesspattern.aggregates.data-store.field",
      "source_spec_node_id": "data-store.accesspattern",
      "source_layer": "data-store",
      "destination_spec_node_id": "data-store.field",
      "destination_layer": "data-store",
      "predicate": "aggregates",
      "cardinality": "many-to-one",
      "strength": "medium",
      "required": false
    },
    "data-store.accesspattern.aggregates.data-store.index": {
      "id": "data-store.accesspattern.aggregates.data-store.index",
      "source_spec_node_id": "data-store.accesspattern",
      "source_layer": "data-store",
      "destination_spec_node_id": "data-store.index",
      "destination_layer": "data-store",
      "predicate": "aggregates",
      "cardinality": "many-to-one",
      "strength": "medium",
      "required": false
    },
    "data-store.accesspattern.triggers.data-store.eventhandler": {
      "id": "data-store.accesspattern.triggers.data-store.eventhandler",
      "source_spec_node_id": "data-store.accesspattern",
      "source_layer": "data-store",
      "destination_spec_node_id": "data-store.eventhandler",
      "destination_layer": "data-store",
      "predicate": "triggers",
      "cardinality": "many-to-one",
      "strength": "medium",
      "required": false
    },
    "data-store.accesspattern.triggers.data-store.storedlogic": {
      "id": "data-store.accesspattern.triggers.data-store.storedlogic",
      "source_spec_node_id": "data-store.accesspattern",
      "source_layer": "data-store",
      "destination_spec_node_id": "data-store.storedlogic",
      "destination_layer": "data-store",
      "predicate": "triggers",
      "cardinality": "many-to-one",
      "strength": "medium",
      "required": false
    },
    "data-store.accesspattern.uses.data-store.index": {
      "id": "data-store.accesspattern.uses.data-store.index",
      "source_spec_node_id": "data-store.accesspattern",
      "source_layer": "data-store",
      "destination_spec_node_id": "data-store.index",
      "destination_layer": "data-store",
      "predicate": "uses",
      "cardinality": "many-to-one",
      "strength": "medium",
      "required": false
    },
    "data-store.collection.composes.data-store.collection": {
      "id": "data-store.collection.composes.data-store.collection",
      "source_spec_node_id": "data-store.collection",
      "source_layer": "data-store",
      "destination_spec_node_id": "data-store.collection",
      "destination_layer": "data-store",
      "predicate": "composes",
      "cardinality": "many-to-many",
      "strength": "medium",
      "required": false
    },
    "data-store.collection.composes.data-store.eventhandler": {
      "id": "data-store.collection.composes.data-store.eventhandler",
      "source_spec_node_id": "data-store.collection",
      "source_layer": "data-store",
      "destination_spec_node_id": "data-store.eventhandler",
      "destination_layer": "data-store",
      "predicate": "composes",
      "cardinality": "many-to-one",
      "strength": "medium",
      "required": false
    },
    "data-store.collection.composes.data-store.field": {
      "id": "data-store.collection.composes.data-store.field",
      "source_spec_node_id": "data-store.collection",
      "source_layer": "data-store",
      "destination_spec_node_id": "data-store.field",
      "destination_layer": "data-store",
      "predicate": "composes",
      "cardinality": "many-to-many",
      "strength": "medium",
      "required": false
    },
    "data-store.collection.composes.data-store.index": {
      "id": "data-store.collection.composes.data-store.index",
      "source_spec_node_id": "data-store.collection",
      "source_layer": "data-store",
      "destination_spec_node_id": "data-store.index",
      "destination_layer": "data-store",
      "predicate": "composes",
      "cardinality": "many-to-many",
      "strength": "medium",
      "required": false
    },
    "data-store.collection.composes.data-store.namespace": {
      "id": "data-store.collection.composes.data-store.namespace",
      "source_spec_node_id": "data-store.collection",
      "source_layer": "data-store",
      "destination_spec_node_id": "data-store.namespace",
      "destination_layer": "data-store",
      "predicate": "composes",
      "cardinality": "many-to-many",
      "strength": "medium",
      "required": false
    },
    "data-store.collection.composes.data-store.validationrule": {
      "id": "data-store.collection.composes.data-store.validationrule",
      "source_spec_node_id": "data-store.collection",
      "source_layer": "data-store",
      "destination_spec_node_id": "data-store.validationrule",
      "destination_layer": "data-store",
      "predicate": "composes",
      "cardinality": "many-to-many",
      "strength": "medium",
      "required": false
    },
    "data-store.collection.references.data-store.collection": {
      "id": "data-store.collection.references.data-store.collection",
      "source_spec_node_id": "data-store.collection",
      "source_layer": "data-store",
      "destination_spec_node_id": "data-store.collection",
      "destination_layer": "data-store",
      "predicate": "references",
      "cardinality": "many-to-one",
      "strength": "medium",
      "required": false
    },
    "data-store.database.composes.data-store.collection": {
      "id": "data-store.database.composes.data-store.collection",
      "source_spec_node_id": "data-store.database",
      "source_layer": "data-store",
      "destination_spec_node_id": "data-store.collection",
      "destination_layer": "data-store",
      "predicate": "composes",
      "cardinality": "many-to-many",
      "strength": "medium",
      "required": false
    },
    "data-store.database.composes.data-store.field": {
      "id": "data-store.database.composes.data-store.field",
      "source_spec_node_id": "data-store.database",
      "source_layer": "data-store",
      "destination_spec_node_id": "data-store.field",
      "destination_layer": "data-store",
      "predicate": "composes",
      "cardinality": "many-to-many",
      "strength": "medium",
      "required": false
    },
    "data-store.database.composes.data-store.index": {
      "id": "data-store.database.composes.data-store.index",
      "source_spec_node_id": "data-store.database",
      "source_layer": "data-store",
      "destination_spec_node_id": "data-store.index",
      "destination_layer": "data-store",
      "predicate": "composes",
      "cardinality": "many-to-many",
      "strength": "medium",
      "required": false
    },
    "data-store.database.composes.data-store.namespace": {
      "id": "data-store.database.composes.data-store.namespace",
      "source_spec_node_id": "data-store.database",
      "source_layer": "data-store",
      "destination_spec_node_id": "data-store.namespace",
      "destination_layer": "data-store",
      "predicate": "composes",
      "cardinality": "many-to-many",
      "strength": "medium",
      "required": false
    },
    "data-store.database.composes.data-store.validationrule": {
      "id": "data-store.database.composes.data-store.validationrule",
      "source_spec_node_id": "data-store.database",
      "source_layer": "data-store",
      "destination_spec_node_id": "data-store.validationrule",
      "destination_layer": "data-store",
      "predicate": "composes",
      "cardinality": "many-to-many",
      "strength": "medium",
      "required": false
    },
    "data-store.database.composes.data-store.view": {
      "id": "data-store.database.composes.data-store.view",
      "source_spec_node_id": "data-store.database",
      "source_layer": "data-store",
      "destination_spec_node_id": "data-store.view",
      "destination_layer": "data-store",
      "predicate": "composes",
      "cardinality": "many-to-one",
      "strength": "medium",
      "required": false
    },
    "data-store.eventhandler.triggers.data-store.storedlogic": {
      "id": "data-store.eventhandler.triggers.data-store.storedlogic",
      "source_spec_node_id": "data-store.eventhandler",
      "source_layer": "data-store",
      "destination_spec_node_id": "data-store.storedlogic",
      "destination_layer": "data-store",
      "predicate": "triggers",
      "cardinality": "many-to-many",
      "strength": "medium",
      "required": false
    },
    "data-store.field.composes.data-store.field": {
      "id": "data-store.field.composes.data-store.field",
      "source_spec_node_id": "data-store.field",
      "source_layer": "data-store",
      "destination_spec_node_id": "data-store.field",
      "destination_layer": "data-store",
      "predicate": "composes",
      "cardinality": "many-to-one",
      "strength": "medium",
      "required": false
    },
    "data-store.field.triggers.data-store.eventhandler": {
      "id": "data-store.field.triggers.data-store.eventhandler",
      "source_spec_node_id": "data-store.field",
      "source_layer": "data-store",
      "destination_spec_node_id": "data-store.eventhandler",
      "destination_layer": "data-store",
      "predicate": "triggers",
      "cardinality": "many-to-one",
      "strength": "medium",
      "required": false
    },
    "data-store.field.triggers.data-store.storedlogic": {
      "id": "data-store.field.triggers.data-store.storedlogic",
      "source_spec_node_id": "data-store.field",
      "source_layer": "data-store",
      "destination_spec_node_id": "data-store.storedlogic",
      "destination_layer": "data-store",
      "predicate": "triggers",
      "cardinality": "many-to-one",
      "strength": "medium",
      "required": false
    },
    "data-store.field.triggers.data-store.validationrule": {
      "id": "data-store.field.triggers.data-store.validationrule",
      "source_spec_node_id": "data-store.field",
      "source_layer": "data-store",
      "destination_spec_node_id": "data-store.validationrule",
      "destination_layer": "data-store",
      "predicate": "triggers",
      "cardinality": "many-to-one",
      "strength": "medium",
      "required": false
    },
    "data-store.index.aggregates.data-store.field": {
      "id": "data-store.index.aggregates.data-store.field",
      "source_spec_node_id": "data-store.index",
      "source_layer": "data-store",
      "destination_spec_node_id": "data-store.field",
      "destination_layer": "data-store",
      "predicate": "aggregates",
      "cardinality": "many-to-many",
      "strength": "medium",
      "required": false
    },
    "data-store.namespace.composes.data-store.collection": {
      "id": "data-store.namespace.composes.data-store.collection",
      "source_spec_node_id": "data-store.namespace",
      "source_layer": "data-store",
      "destination_spec_node_id": "data-store.collection",
      "destination_layer": "data-store",
      "predicate": "composes",
      "cardinality": "many-to-many",
      "strength": "medium",
      "required": false
    },
    "data-store.namespace.composes.data-store.field": {
      "id": "data-store.namespace.composes.data-store.field",
      "source_spec_node_id": "data-store.namespace",
      "source_layer": "data-store",
      "destination_spec_node_id": "data-store.field",
      "destination_layer": "data-store",
      "predicate": "composes",
      "cardinality": "many-to-many",
      "strength": "medium",
      "required": false
    },
    "data-store.namespace.composes.data-store.index": {
      "id": "data-store.namespace.composes.data-store.index",
      "source_spec_node_id": "data-store.namespace",
      "source_layer": "data-store",
      "destination_spec_node_id": "data-store.index",
      "destination_layer": "data-store",
      "predicate": "composes",
      "cardinality": "many-to-many",
      "strength": "medium",
      "required": false
    },
    "data-store.namespace.composes.data-store.namespace": {
      "id": "data-store.namespace.composes.data-store.namespace",
      "source_spec_node_id": "data-store.namespace",
      "source_layer": "data-store",
      "destination_spec_node_id": "data-store.namespace",
      "destination_layer": "data-store",
      "predicate": "composes",
      "cardinality": "many-to-many",
      "strength": "medium",
      "required": false
    },
    "data-store.namespace.composes.data-store.validationrule": {
      "id": "data-store.namespace.composes.data-store.validationrule",
      "source_spec_node_id": "data-store.namespace",
      "source_layer": "data-store",
      "destination_spec_node_id": "data-store.validationrule",
      "destination_layer": "data-store",
      "predicate": "composes",
      "cardinality": "many-to-many",
      "strength": "medium",
      "required": false
    },
    "data-store.namespace.composes.data-store.view": {
      "id": "data-store.namespace.composes.data-store.view",
      "source_spec_node_id": "data-store.namespace",
      "source_layer": "data-store",
      "destination_spec_node_id": "data-store.view",
      "destination_layer": "data-store",
      "predicate": "composes",
      "cardinality": "many-to-one",
      "strength": "medium",
      "required": false
    },
    "data-store.retentionpolicy.aggregates.data-store.collection": {
      "id": "data-store.retentionpolicy.aggregates.data-store.collection",
      "source_spec_node_id": "data-store.retentionpolicy",
      "source_layer": "data-store",
      "destination_spec_node_id": "data-store.collection",
      "destination_layer": "data-store",
      "predicate": "aggregates",
      "cardinality": "many-to-one",
      "strength": "medium",
      "required": false
    },
    "data-store.retentionpolicy.aggregates.data-store.namespace": {
      "id": "data-store.retentionpolicy.aggregates.data-store.namespace",
      "source_spec_node_id": "data-store.retentionpolicy",
      "source_layer": "data-store",
      "destination_spec_node_id": "data-store.namespace",
      "destination_layer": "data-store",
      "predicate": "aggregates",
      "cardinality": "many-to-one",
      "strength": "medium",
      "required": false
    },
    "data-store.retentionpolicy.governs.data-store.collection": {
      "id": "data-store.retentionpolicy.governs.data-store.collection",
      "source_spec_node_id": "data-store.retentionpolicy",
      "source_layer": "data-store",
      "destination_spec_node_id": "data-store.collection",
      "destination_layer": "data-store",
      "predicate": "governs",
      "cardinality": "many-to-one",
      "strength": "medium",
      "required": false
    },
    "data-store.retentionpolicy.governs.data-store.namespace": {
      "id": "data-store.retentionpolicy.governs.data-store.namespace",
      "source_spec_node_id": "data-store.retentionpolicy",
      "source_layer": "data-store",
      "destination_spec_node_id": "data-store.namespace",
      "destination_layer": "data-store",
      "predicate": "governs",
      "cardinality": "many-to-one",
      "strength": "medium",
      "required": false
    },
    "data-store.retentionpolicy.triggers.data-store.eventhandler": {
      "id": "data-store.retentionpolicy.triggers.data-store.eventhandler",
      "source_spec_node_id": "data-store.retentionpolicy",
      "source_layer": "data-store",
      "destination_spec_node_id": "data-store.eventhandler",
      "destination_layer": "data-store",
      "predicate": "triggers",
      "cardinality": "many-to-one",
      "strength": "medium",
      "required": false
    },
    "data-store.retentionpolicy.triggers.data-store.storedlogic": {
      "id": "data-store.retentionpolicy.triggers.data-store.storedlogic",
      "source_spec_node_id": "data-store.retentionpolicy",
      "source_layer": "data-store",
      "destination_spec_node_id": "data-store.storedlogic",
      "destination_layer": "data-store",
      "predicate": "triggers",
      "cardinality": "many-to-one",
      "strength": "medium",
      "required": false
    },
    "data-store.storedlogic.accesses.data-store.collection": {
      "id": "data-store.storedlogic.accesses.data-store.collection",
      "source_spec_node_id": "data-store.storedlogic",
      "source_layer": "data-store",
      "destination_spec_node_id": "data-store.collection",
      "destination_layer": "data-store",
      "predicate": "accesses",
      "cardinality": "many-to-one",
      "strength": "medium",
      "required": false
    },
    "data-store.storedlogic.aggregates.data-store.collection": {
      "id": "data-store.storedlogic.aggregates.data-store.collection",
      "source_spec_node_id": "data-store.storedlogic",
      "source_layer": "data-store",
      "destination_spec_node_id": "data-store.collection",
      "destination_layer": "data-store",
      "predicate": "aggregates",
      "cardinality": "many-to-one",
      "strength": "medium",
      "required": false
    },
    "data-store.storedlogic.aggregates.data-store.field": {
      "id": "data-store.storedlogic.aggregates.data-store.field",
      "source_spec_node_id": "data-store.storedlogic",
      "source_layer": "data-store",
      "destination_spec_node_id": "data-store.field",
      "destination_layer": "data-store",
      "predicate": "aggregates",
      "cardinality": "many-to-one",
      "strength": "medium",
      "required": false
    },
    "data-store.storedlogic.composes.data-store.storedlogic": {
      "id": "data-store.storedlogic.composes.data-store.storedlogic",
      "source_spec_node_id": "data-store.storedlogic",
      "source_layer": "data-store",
      "destination_spec_node_id": "data-store.storedlogic",
      "destination_layer": "data-store",
      "predicate": "composes",
      "cardinality": "many-to-one",
      "strength": "medium",
      "required": false
    },
    "data-store.storedlogic.composes.data-store.validationrule": {
      "id": "data-store.storedlogic.composes.data-store.validationrule",
      "source_spec_node_id": "data-store.storedlogic",
      "source_layer": "data-store",
      "destination_spec_node_id": "data-store.validationrule",
      "destination_layer": "data-store",
      "predicate": "composes",
      "cardinality": "many-to-one",
      "strength": "medium",
      "required": false
    },
    "data-store.storedlogic.triggers.data-store.storedlogic": {
      "id": "data-store.storedlogic.triggers.data-store.storedlogic",
      "source_spec_node_id": "data-store.storedlogic",
      "source_layer": "data-store",
      "destination_spec_node_id": "data-store.storedlogic",
      "destination_layer": "data-store",
      "predicate": "triggers",
      "cardinality": "many-to-one",
      "strength": "medium",
      "required": false
    },
    "data-store.storedlogic.triggers.data-store.view": {
      "id": "data-store.storedlogic.triggers.data-store.view",
      "source_spec_node_id": "data-store.storedlogic",
      "source_layer": "data-store",
      "destination_spec_node_id": "data-store.view",
      "destination_layer": "data-store",
      "predicate": "triggers",
      "cardinality": "many-to-one",
      "strength": "medium",
      "required": false
    },
    "data-store.validationrule.aggregates.data-store.field": {
      "id": "data-store.validationrule.aggregates.data-store.field",
      "source_spec_node_id": "data-store.validationrule",
      "source_layer": "data-store",
      "destination_spec_node_id": "data-store.field",
      "destination_layer": "data-store",
      "predicate": "aggregates",
      "cardinality": "many-to-many",
      "strength": "medium",
      "required": false
    },
    "data-store.view.aggregates.data-store.collection": {
      "id": "data-store.view.aggregates.data-store.collection",
      "source_spec_node_id": "data-store.view",
      "source_layer": "data-store",
      "destination_spec_node_id": "data-store.collection",
      "destination_layer": "data-store",
      "predicate": "aggregates",
      "cardinality": "many-to-one",
      "strength": "medium",
      "required": false
    },
    "data-store.view.aggregates.data-store.field": {
      "id": "data-store.view.aggregates.data-store.field",
      "source_spec_node_id": "data-store.view",
      "source_layer": "data-store",
      "destination_spec_node_id": "data-store.field",
      "destination_layer": "data-store",
      "predicate": "aggregates",
      "cardinality": "many-to-one",
      "strength": "medium",
      "required": false
    },
    "data-store.view.composes.data-store.index": {
      "id": "data-store.view.composes.data-store.index",
      "source_spec_node_id": "data-store.view",
      "source_layer": "data-store",
      "destination_spec_node_id": "data-store.index",
      "destination_layer": "data-store",
      "predicate": "composes",
      "cardinality": "many-to-one",
      "strength": "medium",
      "required": false
    },
    "data-store.view.derives-from.data-store.collection": {
      "id": "data-store.view.derives-from.data-store.collection",
      "source_spec_node_id": "data-store.view",
      "source_layer": "data-store",
      "destination_spec_node_id": "data-store.collection",
      "destination_layer": "data-store",
      "predicate": "derives-from",
      "cardinality": "many-to-one",
      "strength": "medium",
      "required": false
    },
    "data-store.view.derives-from.data-store.view": {
      "id": "data-store.view.derives-from.data-store.view",
      "source_spec_node_id": "data-store.view",
      "source_layer": "data-store",
      "destination_spec_node_id": "data-store.view",
      "destination_layer": "data-store",
      "predicate": "derives-from",
      "cardinality": "many-to-one",
      "strength": "medium",
      "required": false
    }
  }
}
