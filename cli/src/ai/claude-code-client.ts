/**
 * Claude Code CLI Client
 *
 * Implements chat functionality using Claude Code CLI subprocess.
 * Uses structured JSON streaming output for reliable parsing.
 *
 * Key features:
 * - Availability detection via `which claude`
 * - JSON event stream parsing
 * - Agent support (dr-architect)
 * - Tool use detection and display
 * - Session management per process invocation
 */

import { BaseChatClient, ChatOptions } from './base-chat-client.js';
import { spawnSync, spawn, ChildProcess } from 'child_process';
import ansis from 'ansis';
import { getChatLogger } from '../utils/chat-logger.js';

/**
 * Claude Code CLI event types
 */
interface ClaudeEvent {
  type: string;
  message?: {
    content?: Array<{
      type: string;
      text?: string;
      name?: string;
    }>;
  };
}

/**
 * Claude Code CLI Client
 */
export class ClaudeCodeClient extends BaseChatClient {
  /**
   * Check if Claude Code CLI is available
   */
  async isAvailable(): Promise<boolean> {
    try {
      const result = spawnSync('which', ['claude'], {
        stdio: 'pipe',
        encoding: 'utf-8',
      });
      return result.status === 0;
    } catch {
      return false;
    }
  }

  /**
   * Send a message to Claude Code CLI and stream the response
   * @param message The user's message
   * @param options Chat options
   */
  async sendMessage(message: string, options?: ChatOptions): Promise<void> {
    // Log the user message
    const logger = getChatLogger();
    if (logger) {
      await logger.logUserMessage(message, {
        client: 'Claude Code',
        agent: options?.agent,
      });
    }

    // Create session for this message
    // Note: Claude Code doesn't support cross-invocation sessions,
    // each invocation is a fresh conversation
    this.createSession();
    this.updateSessionTimestamp();

    return new Promise((resolve, reject) => {
      const proc = this.spawnClaudeProcess(message, options);

      let buffer = '';
      let assistantOutput = '';

      // Handle stdout - JSON event stream
      proc.stdout?.on('data', (data: Buffer) => {
        const chunk = data.toString();
        buffer += chunk;

        // Process complete lines (each line is a JSON event)
        const lines = buffer.split('\n');
        buffer = lines.pop() || '';

        for (const line of lines) {
          if (!line.trim()) continue;

          try {
            const event: ClaudeEvent = JSON.parse(line);
            const output = this.handleClaudeEvent(event);
            if (output) {
              assistantOutput += output;
            }
          } catch {
            // Non-JSON line, print as-is
            process.stdout.write(line + '\n');
            assistantOutput += line + '\n';
          }
        }
      });

      // Handle stderr (usually quiet unless there's an error)
      proc.stderr?.on('data', (data: Buffer) => {
        const errorText = data.toString();
        // Claude Code stderr is usually verbose logging
        // We log it but don't display unless it's an actual error
        if (logger && errorText.includes('error')) {
          void logger.logError(errorText, {
            source: 'stderr',
            client: 'Claude Code',
          });
        }
      });

      // Handle errors
      proc.on('error', (error) => {
        if (logger) {
          void logger.logError(error.message, {
            source: 'process',
            client: 'Claude Code',
            stack: error.stack,
          });
        }
        reject(error);
      });

      // Handle process exit
      proc.on('close', (exitCode) => {
        // Print any remaining buffer
        if (buffer.trim()) {
          try {
            const event: ClaudeEvent = JSON.parse(buffer);
            const output = this.handleClaudeEvent(event);
            if (output) {
              assistantOutput += output;
            }
          } catch {
            process.stdout.write(buffer);
            assistantOutput += buffer;
          }
        }

        if (exitCode === 0) {
          // Log assistant message if we got output
          if (logger && assistantOutput.trim()) {
            void logger.logAssistantMessage(assistantOutput, {
              client: 'Claude Code',
            });
          }
          resolve();
        } else {
          const errorMsg = `Claude process exited with code ${exitCode}`;
          if (logger) {
            void logger.logError(errorMsg, {
              exitCode,
              client: 'Claude Code',
            });
          }
          reject(new Error(errorMsg));
        }
      });
    });
  }

  /**
   * Handle a Claude Code event from the JSON stream
   * @param event The Claude event to handle
   * @returns The output text generated by the event, if any
   */
  private handleClaudeEvent(event: ClaudeEvent): string {
    let output = '';

    if (event.type === 'assistant') {
      const content = event.message?.content || [];
      for (const block of content) {
        if (block.type === 'text') {
          const text = block.text || '';
          process.stdout.write(text);
          output += text;
        } else if (block.type === 'tool_use') {
          const toolMsg = ansis.dim(`\n[Using tool: ${block.name}]\n`);
          process.stdout.write(toolMsg);
          output += toolMsg;
        }
      }
    }

    return output;
  }

  /**
   * Spawn the Claude Code CLI process
   * @param message The message to send
   * @param options Chat options
   * @returns The spawned child process
   */
  private spawnClaudeProcess(
    message: string,
    options?: ChatOptions
  ): ChildProcess {
    const args = ['--print'];

    // Add dangerously-skip-permissions flag if withDanger is enabled
    if (options?.withDanger) {
      args.push('--dangerously-skip-permissions');
    }

    args.push('--verbose', '--output-format', 'stream-json');

    // Add agent if specified
    if (options?.agent) {
      args.unshift('--agent', options.agent);
    }

    const cwd = options?.workingDirectory || process.cwd();

    // Log the command that's being executed
    const logger = getChatLogger();
    if (logger) {
      void logger.logCommand('claude', args, {
        client: 'Claude Code',
        workingDirectory: cwd,
        agent: options?.agent,
        withDanger: options?.withDanger || false,
        messageLength: message.length,
        hasVerboseFlag: args.includes('--verbose'),
        hasOutputFormat: args.includes('--output-format'),
      });
    }

    const proc = spawn('claude', args, {
      cwd,
      stdio: ['pipe', 'pipe', 'pipe'],
    });

    // Send message via stdin
    proc.stdin?.write(message);
    proc.stdin?.end();

    return proc;
  }

  /**
   * Get the name of this client
   */
  getClientName(): string {
    return 'Claude Code';
  }
}
