#!/usr/bin/env -S node --loader tsx

/**
 * generate-registry.ts
 *
 * Build-time code generation that derives layer metadata from spec/layers/*.layer.json
 * and generates:
 *   - cli/src/generated/layer-registry.ts (LayerRegistry and typed exports)
 *   - cli/src/generated/layer-types.ts (LayerId and related union types)
 *
 * This script is run automatically during npm run build (via prebuild script)
 */

import * as fs from "fs";
import * as path from "path";
import { fileURLToPath } from "url";

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const CLI_DIR = path.join(__dirname, "..");
const BUNDLED_LAYERS_DIR = path.join(CLI_DIR, "src", "schemas", "bundled", "layers");
const GENERATED_DIR = path.join(CLI_DIR, "src", "generated");

interface LayerInstance {
  id: string;
  number: number;
  name: string;
  description: string;
  node_types: string[];
  inspired_by?: {
    standard: string;
    version: string;
    url?: string;
  };
}

interface LayerMetadata {
  id: string;
  number: number;
  name: string;
  description: string;
  nodeTypes: string[];
  inspiredBy?: {
    standard: string;
    version: string;
    url?: string;
  };
}

/**
 * Load all layer instance files from bundled directory
 */
function loadLayerInstances(): LayerMetadata[] {
  if (!fs.existsSync(BUNDLED_LAYERS_DIR)) {
    console.error(`ERROR: Layer instances directory not found at ${BUNDLED_LAYERS_DIR}`);
    console.error("Run 'npm run sync-schemas' first to copy layer instances from spec/");
    process.exit(1);
  }

  const files = fs
    .readdirSync(BUNDLED_LAYERS_DIR)
    .filter((f) => f.endsWith(".layer.json"))
    .sort();

  if (files.length === 0) {
    console.error(`ERROR: No .layer.json files found in ${BUNDLED_LAYERS_DIR}`);
    process.exit(1);
  }

  const layers: LayerMetadata[] = files.map((file) => {
    const filePath = path.join(BUNDLED_LAYERS_DIR, file);
    const content = fs.readFileSync(filePath, "utf-8");
    const instance: LayerInstance = JSON.parse(content);

    return {
      id: instance.id,
      number: instance.number,
      name: instance.name,
      description: instance.description,
      nodeTypes: instance.node_types,
      ...(instance.inspired_by && { inspiredBy: instance.inspired_by }),
    };
  });

  // Validate we have all 12 layers
  if (layers.length !== 12) {
    console.error(`ERROR: Expected 12 layers, but found ${layers.length}`);
    console.error(`Files found: ${files.join(", ")}`);
    process.exit(1);
  }

  // Validate layers are numbered 1-12
  const numbers = layers.map((l) => l.number).sort((a, b) => a - b);
  if (numbers.join(",") !== "1,2,3,4,5,6,7,8,9,10,11,12") {
    console.error(`ERROR: Invalid layer numbers: ${numbers.join(", ")}`);
    process.exit(1);
  }

  return layers.sort((a, b) => a.number - b.number);
}

/**
 * Generate layer-registry.ts with LayerRegistry interface and exports
 */
function generateLayerRegistry(layers: LayerMetadata[]): string {
  const layerHierarchy = layers.map((l) => l.number).join(", ");

  // Helper to convert layer ID to valid TypeScript identifier
  const toIdentifier = (id: string): string => id.replace(/-/g, "_").toUpperCase();

  // Generate constant declarations FIRST
  const constants = layers
    .map(
      (l) => `
const LAYER_METADATA_${toIdentifier(l.id)}: LayerMetadata = {
  id: "${l.id}",
  number: ${l.number},
  name: "${l.name}",
  description: "${l.description}",
  nodeTypes: [${l.nodeTypes.map((t) => `"${t}"`).join(", ")}],${
        l.inspiredBy
          ? `
  inspiredBy: {
    standard: "${l.inspiredBy.standard}",
    version: "${l.inspiredBy.version}",${l.inspiredBy.url ? `
    url: "${l.inspiredBy.url}",` : ""}
  },`
          : ""
      }
};`
    )
    .join("\n");

  // Generate Map constructor entries
  const mapEntries = layers
    .map((l) => `    ["${l.id}", LAYER_METADATA_${toIdentifier(l.id)}]`)
    .join(",\n");

  // Generate Map entries indexed by number for O(1) lookup
  const mapEntriesByNumber = layers
    .map((l) => `    [${l.number}, LAYER_METADATA_${toIdentifier(l.id)}]`)
    .join(",\n");

  return `/**
 * GENERATED FILE - DO NOT EDIT
 * This file is automatically generated by scripts/generate-registry.ts
 * during the build process. Changes will be overwritten.
 *
 * Source: spec/layers/*.layer.json
 */

/**
 * Layer metadata derived from specification layer instances
 */
export interface LayerMetadata {
  id: string;           // "motivation", "data-store", etc. (canonical hyphenated form)
  number: number;       // 1-12
  name: string;         // "Motivation Layer", "Data Store Layer"
  description: string;  // Layer description
  nodeTypes: string[];  // ["motivation.goal", "motivation.requirement", ...]
  inspiredBy?: {
    standard: string;
    version: string;
    url?: string;
  };
}

${constants}

/**
 * All 12 layers with metadata, indexed by layer ID
 */
export const LAYERS: Map<string, LayerMetadata> = new Map([
${mapEntries}
]);

/**
 * All 12 layers with metadata, indexed by layer number for O(1) lookup
 */
export const LAYERS_BY_NUMBER: Map<number, LayerMetadata> = new Map([
${mapEntriesByNumber}
]);

/**
 * Layer hierarchy - ordered array of layer numbers for reference validation
 */
export const LAYER_HIERARCHY: readonly number[] = [${layerHierarchy}] as const;

/**
 * Get layer metadata by layer number (1-12)
 */
export function getLayerByNumber(n: number): LayerMetadata | undefined {
  return LAYERS_BY_NUMBER.get(n);
}

/**
 * Get layer metadata by canonical layer ID
 */
export function getLayerById(id: string): LayerMetadata | undefined {
  return LAYERS.get(id);
}

/**
 * Check if a layer ID is valid
 */
export function isValidLayer(id: string): boolean {
  return LAYERS.has(id);
}

/**
 * Get all valid node types for a layer
 */
export function getNodeTypesForLayer(layerId: string): string[] {
  const layer = LAYERS.get(layerId);
  return layer ? layer.nodeTypes : [];
}

/**
 * Get all canonical layer IDs in numeric order
 */
export function getAllLayerIds(): string[] {
  return Array.from(LAYERS.values())
    .sort((a, b) => a.number - b.number)
    .map((l) => l.id);
}

/**
 * Get all layers in numeric order
 */
export function getAllLayers(): LayerMetadata[] {
  return Array.from(LAYERS.values()).sort((a, b) => a.number - b.number);
}
`;
}

/**
 * Generate layer-types.ts with LayerId union type
 */
function generateLayerTypes(layers: LayerMetadata[]): string {
  const layerIdType = layers.map((l) => `"${l.id}"`).join(" | ");

  return `/**
 * GENERATED FILE - DO NOT EDIT
 * This file is automatically generated by scripts/generate-registry.ts
 * during the build process. Changes will be overwritten.
 *
 * Source: spec/layers/*.layer.json
 */

/**
 * Union type of all valid layer IDs in the 12-layer architecture model
 */
export type LayerId = ${layerIdType};

/**
 * Check if a value is a valid LayerId
 */
export function isLayerId(value: unknown): value is LayerId {
  const validIds: LayerId[] = [${layers.map((l) => `"${l.id}"`).join(", ")}];
  return typeof value === "string" && validIds.includes(value as LayerId);
}
`;
}

/**
 * Ensure generated directory exists
 */
function ensureGeneratedDir(): void {
  if (!fs.existsSync(GENERATED_DIR)) {
    fs.mkdirSync(GENERATED_DIR, { recursive: true });
  }
}

/**
 * Generate index.ts barrel file
 */
function generateIndexBarrel(): string {
  return `/**
 * GENERATED FILE - DO NOT EDIT
 * This file is automatically generated by scripts/generate-registry.ts
 * during the build process. Changes will be overwritten.
 *
 * Central exports for all generated code
 */

export * from "./layer-registry.js";
export * from "./layer-types.js";
`;
}

/**
 * Write generated files
 */
function writeGeneratedFiles(layers: LayerMetadata[]): void {
  ensureGeneratedDir();

  const registryPath = path.join(GENERATED_DIR, "layer-registry.ts");
  const typesPath = path.join(GENERATED_DIR, "layer-types.ts");
  const indexPath = path.join(GENERATED_DIR, "index.ts");

  const registryContent = generateLayerRegistry(layers);
  const typesContent = generateLayerTypes(layers);
  const indexContent = generateIndexBarrel();

  fs.writeFileSync(registryPath, registryContent);
  fs.writeFileSync(typesPath, typesContent);
  fs.writeFileSync(indexPath, indexContent);

  console.log(`✓ Generated ${registryPath}`);
  console.log(`✓ Generated ${typesPath}`);
  console.log(`✓ Generated ${indexPath}`);
}

/**
 * Main entry point
 */
async function main(): Promise<void> {
  try {
    console.log("Generating layer registry from spec layer instances...");
    const layers = loadLayerInstances();
    console.log(`✓ Loaded ${layers.length} layer instances`);
    writeGeneratedFiles(layers);
    console.log("✓ Layer registry generation complete");
  } catch (error) {
    console.error("ERROR: Layer registry generation failed:");
    console.error(error);
    process.exit(1);
  }
}

main();
