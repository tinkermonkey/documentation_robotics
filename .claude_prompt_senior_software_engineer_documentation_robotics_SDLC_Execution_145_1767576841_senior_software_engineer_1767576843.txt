
You are a Senior Software Engineer.

I implement clean, well thought out code with proper error handling and maintainable architecture.

**Issue Title**: Phase 2: Implement `dr claude` command with all subcommands

**Description**:
Create the Claude integration manager extending the base manager, implement all five subcommands (install, update, remove, status, list), and register the command group in the CLI. This provides full parity with the Python CLI's Claude integration functionality.

## Requirements
- FR1: Claude Integration Command with all subcommands
- FR1.1: Install subcommand with component filtering (--reference-only, --commands-only, --agents-only, --skills-only, --templates-only)
- FR1.2: Update subcommand with dry-run support and conflict handling
- FR1.3: Remove subcommand with component filtering
- FR1.4: Status subcommand showing version and installation details
- FR1.5: List subcommand showing available components
- FR5: Source File Resolution for both development and production modes
- FR7: User Feedback with progress indicators and status tables

## Design Guidance
**Claude Integration Manager** (`src/integrations/claude-manager.ts`):

```typescript
import { BaseIntegrationManager } from './base-manager.js';
import { ComponentConfig } from './types.js';

export class ClaudeIntegrationManager extends BaseIntegrationManager {
  protected targetDir = '.claude';
  protected versionFileName = '.dr-version';
  protected integrationSourceDir = 'claude_code';
  
  /**
   * Component configuration matching Python CLI structure
   * From python-cli/src/documentation_robotics/commands/claude.py:39-78
   */
  protected components: Record<string, ComponentConfig> = {
    reference_sheets: {
      source: 'reference_sheets',
      target: 'knowledge',
      description: 'Reference documentation for agents',
      prefix: 'dr-',
      type: 'files'
    },
    commands: {
      source: 'commands',
      target: 'commands',
      description: 'Custom commands for Claude Code',
      prefix: 'dr-',
      type: 'dirs'
    },
    agents: {
      source: 'agents',
      target: 'agents',
      description: 'Specialized agents for DR tasks',
      prefix: 'dr-',
      type: 'dirs'
    },
    skills: {
      source: 'skills',
      target: 'skills',
      description: 'Project-specific skills',
      prefix: 'dr-',
      type: 'dirs'
    },
    templates: {
      source: 'templates',
      target: 'templates',
      description: 'Template files for common tasks',
      prefix: 'dr-',
      type: 'files'
    }
  };
  
  /**
   * Install integration files
   */
  async install(options: {
    components?: string[]; // Filter to specific components
    force?: boolean;       // Skip confirmations
  }): Promise<void> {
    // Implementation:
    // 1. Check if already installed, prompt if needed
    // 2. Filter components if specified
    // 3. Call installComponent() for each component
    // 4. Update version file
    // 5. Display success summary with file counts
  }
  
  /**
   * Update installed integration files
   */
  async update(options: {
    components?: string[];
    dryRun?: boolean;
    force?: boolean;
  }): Promise<void> {
    // Implementation:
    // 1. Load version file
    // 2. Check for updates using checkUpdates()
    // 3. Detect obsolete files
    // 4. Display change summary
    // 5. Handle conflicts (user-modified + source-changed)
    // 6. Apply updates if not dry-run
    // 7. Update version file
  }
  
  /**
   * Remove integration files
   */
  async remove(options: {
    components?: string[];
    force?: boolean;
  }): Promise<void> {
    // Implementation:
    // 1. Check if installed
    // 2. Filter components if specified
    // 3. Prompt for confirmation unless force
    // 4. Delete files and directories
    // 5. Remove version file
  }
  
  /**
   * Display installation status
   */
  async status(): Promise<void> {
    // Implementation:
    // 1. Check if installed
    // 2. Load version file
    // 3. Display version comparison with current CLI
    // 4. Show component status table with file counts
    // 5. Indicate if update is available
  }
  
  /**
   * List available components
   */
  async list(): Promise<void> {
    // Implementation:
    // 1. Read source directory
    // 2. Count files per component
    // 3. Display table with descriptions
  }
}
```

**Command Module** (`src/commands/claude.ts`):

```typescript
import { Command } from 'commander';
import { ClaudeIntegrationManager } from '../integrations/claude-manager.js';
import * as clack from '@clack/prompts';
import ansis from 'ansis';

export function claudeCommands(program: Command): void {
  const claude = program
    .command('claude')
    .description('Manage Claude Code integration');
  
  // Install subcommand
  claude
    .command('install')
    .description('Install Claude Code integration files')
    .option('--reference-only', 'Install only reference sheets')
    .option('--commands-only', 'Install only commands')
    .option('--agents-only', 'Install only agents')
    .option('--skills-only', 'Install only skills')
    .option('--templates-only', 'Install only templates')
    .option('-f, --force', 'Skip confirmation prompts')
    .action(async (options) => {
      const manager = new ClaudeIntegrationManager();
      
      // Build component filter from flags
      const components: string[] = [];
      if (options.referenceOnly) components.push('reference_sheets');
      if (options.commandsOnly) components.push('commands');
      if (options.agentsOnly) components.push('agents');
      if (options.skillsOnly) components.push('skills');
      if (options.templatesOnly) components.push('templates');
      
      await manager.install({
        components: components.length > 0 ? components : undefined,
        force: options.force
      });
    });
  
  // Update subcommand
  claude
    .command('update')
    .description('Update installed Claude Code integration')
    .option('--dry-run', 'Preview changes without applying')
    .option('-f, --force', 'Skip confirmation prompts')
    .action(async (options) => {
      const manager = new ClaudeIntegrationManager();
      await manager.update({
        dryRun: options.dryRun,
        force: options.force
      });
    });
  
  // Remove subcommand
  claude
    .command('remove')
    .description('Remove Claude Code integration')
    .option('--reference', 'Remove only reference sheets')
    .option('--commands', 'Remove only commands')
    .option('--agents', 'Remove only agents')
    .option('--skills', 'Remove only skills')
    .option('--templates', 'Remove only templates')
    .option('-f, --force', 'Skip confirmation prompts')
    .action(async (options) => {
      const manager = new ClaudeIntegrationManager();
      
      const components: string[] = [];
      if (options.reference) components.push('reference_sheets');
      if (options.commands) components.push('commands');
      if (options.agents) components.push('agents');
      if (options.skills) components.push('skills');
      if (options.templates) components.push('templates');
      
      await manager.remove({
        components: components.length > 0 ? components : undefined,
        force: options.force
      });
    });
  
  // Status subcommand
  claude
    .command('status')
    .description('Show Claude Code integration status')
    .action(async () => {
      const manager = new ClaudeIntegrationManager();
      await manager.status();
    });
  
  // List subcommand
  claude
    .command('list')
    .description('List available Claude Code components')
    .action(async () => {
      const manager = new ClaudeIntegrationManager();
      await manager.list();
    });
}
```

**CLI Registration** (`src/cli.ts`):

```typescript
// Add import at top
import { claudeCommands } from './commands/claude.js';

// Add registration after existing command groups (around line 88)
claudeCommands(program);
```

**User Feedback Patterns**:

Use `@clack/prompts` for interactive confirmations:
```typescript
const response = await clack.confirm({
  message: 'Claude integration already installed. Overwrite?',
});
if (!response) {
  clack.cancel('Installation cancelled');
  process.exit(0);
}
```

Use `ansis` for colored output:
```typescript
console.log(ansis.green('âœ“') + ' Installed 24 files');
console.log(ansis.yellow('âš ') + ' 3 files modified by user');
```

Display progress with spinners:
```typescript
const spinner = clack.spinner();
spinner.start('Installing components...');
// ... perform operations ...
spinner.stop('Installation complete');
```

## Acceptance Criteria
- [ ] `src/integrations/claude-manager.ts` extends base manager with 5 component types
- [ ] `ClaudeIntegrationManager.install()` copies files from bundled source to `.claude/` directory
- [ ] Install command supports all component filtering flags (--reference-only, --commands-only, etc.)
- [ ] `ClaudeIntegrationManager.update()` detects file changes and handles conflicts
- [ ] Update command supports --dry-run flag showing changes without applying
- [ ] `ClaudeIntegrationManager.remove()` deletes files and version file
- [ ] Remove command supports component filtering flags
- [ ] `ClaudeIntegrationManager.status()` displays version comparison and component table
- [ ] `ClaudeIntegrationManager.list()` shows all available components with descriptions
- [ ] `src/commands/claude.ts` registers all 5 subcommands with correct options
- [ ] CLI registration in `src/cli.ts` makes `dr claude` available
- [ ] Interactive prompts use `@clack/prompts` for consistency
- [ ] Output formatting uses `ansis` for colored output
- [ ] Integration tests verify install/update/remove/status/list operations
- [ ] Tests verify both development and production path resolution
- [ ] Code is reviewed and approved

## Dependencies
Phase 1

## Parent Issue
Part of #140

## Discussion
This work is detailed in discussion [141](https://github.com/tinkermonkey/documentation_robotics/discussions/141)

---


## Previous Work and Feedback

The following is the complete history of agent outputs and feedback for this issue.
This includes outputs from ALL previous stages (design, testing, QA, etc.) and any
user feedback. If this issue was returned from testing or QA, pay special attention
to their feedback and address all issues they identified.

## Output from Software Architect

**software_architect** (agent):
# Architecture Design

---

## System Architecture

### High-Level Architecture

The implementation introduces an **integration management subsystem** to the TypeScript CLI, mirroring the Python CLI's existing `ClaudeIntegrationManager` and `CopilotIntegrationManager` patterns. This subsystem operates independently from the core model management functionality while integrating with the existing `upgrade` command flow.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        TypeScript CLI (cli.ts)                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Command Registration                                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚   init   â”‚ â”‚  add     â”‚ â”‚ validate â”‚ â”‚ upgrade  â”‚ â”‚  ...     â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                               â”‚                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â—„â”€â”€â”€â”€â”€NEWâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚  â”‚  claude  â”‚ â”‚  copilot â”‚                                          â”‚
â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜                                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚       â–¼            â–¼                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚              Integration Management Layer (NEW)              â”‚    â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚    â”‚
â”‚  â”‚  â”‚  BaseIntegrationManager                                 â”‚â”‚    â”‚
â”‚  â”‚  â”‚  - File copy/hash operations                            â”‚â”‚    â”‚
â”‚  â”‚  â”‚  - Version file management (YAML)                       â”‚â”‚    â”‚
â”‚  â”‚  â”‚  - Component configuration registry                     â”‚â”‚    â”‚
â”‚  â”‚  â”‚  - Obsolete file detection                              â”‚â”‚    â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚    â”‚
â”‚  â”‚       â–²                        â–²                            â”‚    â”‚
â”‚  â”‚       â”‚                        â”‚                            â”‚    â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚    â”‚
â”‚  â”‚  â”‚ClaudeIntegrationâ”‚    â”‚CopilotIntegrationâ”‚               â”‚    â”‚
â”‚  â”‚  â”‚Manager          â”‚    â”‚Manager           â”‚               â”‚    â”‚
â”‚  â”‚  â”‚- 5 component    â”‚    â”‚- 2 component     â”‚               â”‚    â”‚
â”‚  â”‚  â”‚  types          â”‚    â”‚  types           â”‚               â”‚    â”‚
â”‚  â”‚  â”‚- .claude/ targetâ”‚    â”‚- .github/ target â”‚               â”‚    â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Existing Utilities                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ project-paths.ts â”‚ â”‚ spec-version.ts  â”‚ â”‚    file-io.ts        â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
                                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       Filesystem Structure                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  integrations/claude_code/     â†’ .claude/                           â”‚
â”‚  â”œâ”€â”€ reference_sheets/         â”‚  â”œâ”€â”€ knowledge/                    â”‚
â”‚  â”œâ”€â”€ commands/                  â”‚  â”œâ”€â”€ commands/                     â”‚
â”‚  â”œâ”€â”€ agents/                    â”‚  â”œâ”€â”€ agents/                       â”‚
â”‚  â”œâ”€â”€ skills/                    â”‚  â”œâ”€â”€ skills/                       â”‚
â”‚  â””â”€â”€ templates/                 â”‚  â”œâ”€â”€ templates/                    â”‚
â”‚                                 â”‚  â””â”€â”€ .dr-version (YAML)            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  integrations/github_copilot/  â†’ .github/                           â”‚
â”‚  â”œâ”€â”€ agents/                    â”‚  â”œâ”€â”€ agents/                       â”‚
â”‚  â””â”€â”€ skills/                    â”‚  â”œâ”€â”€ skills/                       â”‚
â”‚                                 â”‚  â””â”€â”€ .dr-copilot-version (YAML)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Integration Points with Existing Codebase

1. **CLI Registration** (`cli.ts:line ~88+`): Register `claude` and `copilot` command groups alongside existing commands
2. **Upgrade Command** (`commands/upgrade.ts:line ~160+`): Add integration version checking after model migration logic
3. **Project Paths** (`utils/project-paths.ts`): Leverage existing `findProjectRoot()` for locating target directories
4. **File I/O** (`utils/file-io.ts`): Reuse existing `fileExists()`, `readJSON()` utilities

## Scalability Design

### File Operations Performance

The implementation handles potentially hundreds of integration files (12 skill directories Ã— multiple files each). Key considerations:

1. **Parallel File Hashing**: When checking for updates, compute SHA256 hashes in parallel for installed vs. source files
2. **Lazy Component Loading**: Only read component metadata when that component is explicitly requested
3. **Early Exit Patterns**: Check version file first; skip full scan if versions match

### Memory Footprint

- Files are processed incrementally (copy one at a time) rather than loading entire directory trees into memory
- Hash computation uses streaming to handle large files without memory pressure
- Version tracking YAML files remain small (~1KB typical)

## Established Patterns

### Pattern 1: Manager Class Architecture (from Python CLI)

The Python CLI establishes a clear pattern for integration managers at `cli-validation/python-cli/src/documentation_robotics/commands/claude.py:39-78`:

```python
class ClaudeIntegrationManager:
    COMPONENTS = {
        "reference_sheets": {
            "source": "reference_sheets",
            "target": KNOWLEDGE_DIR,
            "description": "Reference documentation for agents",
            "prefix": "dr-",
            "type": "files",
        },
        # ... more components
    }
```

The TypeScript implementation must preserve this component registry pattern with the same keys and structure.

### Pattern 2: Version File Format (YAML)

The Python CLI uses YAML for version tracking (`.dr-version`, `.dr-copilot-version`):

```yaml
version: "0.1.0"
installed_at: "2024-01-04T10:30:00"
components:
  reference_sheets:
    dr-layer-reference.md:
      hash: "a1b2c3d4"
      modified: false
```

The TypeScript implementation must produce compatible YAML using the `yaml` package (already in `package.json`).

### Pattern 3: Command Group Structure (from existing CLI)

Following the established pattern in `cli.ts:264-274`:

```typescript
// Element subcommands
const elementGroup = program
  .command('element')
  .description('Element operations');
elementCommands(elementGroup);
```

The `claude` and `copilot` commands should follow this pattern with subcommand registration functions.

### Pattern 4: Source Path Resolution (Development vs Production)

The Python CLI at lines 22-29 handles dual-mode path resolution:

```python
DEV_ROOT = Path(__file__).parents[4] / "integrations" / "claude_code"
PKG_ROOT = Path(__file__).parent.parent / "claude_integration"

if DEV_ROOT.exists():
    INTEGRATION_ROOT = DEV_ROOT
else:
    INTEGRATION_ROOT = PKG_ROOT
```

The TypeScript implementation needs equivalent logic for both development (running from source) and production (npm package distribution).

### Pattern 5: Interactive Prompts (from existing commands)

The upgrade command at `commands/upgrade.ts:219-223` uses `@clack/prompts`:

```typescript
const response = await confirm({
  message: 'Proceed with upgrade?',
});
```

Integration commands must use the same prompt library for consistency.

## Component Reuse

### Existing Utilities to Leverage

| Utility | Location | Usage |
|---------|----------|-------|
| `findProjectRoot()` | `utils/project-paths.ts:39` | Locate project root for target directories |
| `fileExists()` | `utils/file-io.ts` | Check for existing files before operations |
| `readJSON()` | `utils/file-io.ts` | Read manifest files |
| `yaml` package | `package.json` dependencies | Parse/write version files |
| `@clack/prompts` | `package.json` dependencies | Interactive confirmations |
| `ansis` | `package.json` dependencies | Colored CLI output |
| `commander` | `package.json` dependencies | Command registration |

### New Modules Required

| Module | Purpose |
|--------|---------|
| `src/integrations/base-manager.ts` | Abstract base class with shared logic |
| `src/integrations/claude-manager.ts` | Claude Code integration manager |
| `src/integrations/copilot-manager.ts` | GitHub Copilot integration manager |
| `src/integrations/types.ts` | Shared interfaces and types |
| `src/integrations/hash-utils.ts` | SHA256 hashing utilities |
| `src/commands/claude.ts` | Claude command group and subcommands |
| `src/commands/copilot.ts` | Copilot command group and subcommands |

### Build System Updates

The integration files at `integrations/claude_code/` and `integrations/github_copilot/` must be bundled with the CLI distribution. This requires updates to:

1. **`esbuild.config.js`**: Copy integration directories to `dist/integrations/`
2. **`package.json` "files"**: Include `dist/integrations/**` in npm package

## Implementation Plan

### Phase 1: Foundation Infrastructure

**Step 1.1: Create Type Definitions**
- Create `src/integrations/types.ts` with interfaces:
  - `ComponentConfig` - matches Python COMPONENTS dict structure
  - `VersionData` - version file YAML schema
  - `FileChange` - for update detection
  - `ObsoleteFile` - for cleanup detection

**Step 1.2: Create Hash Utilities**
- Create `src/integrations/hash-utils.ts`
- Implement `computeFileHash(filePath: string): Promise<string>` using Node.js `crypto` module
- Use SHA256, truncated to 8 characters (matching Python implementation)

**Step 1.3: Create Base Integration Manager**
- Create `src/integrations/base-manager.ts`
- Implement abstract class with shared methods:
  - `_isInstalled(): Promise<boolean>`
  - `_loadVersionFile(): Promise<VersionData>`
  - `_updateVersionFile(): Promise<void>`
  - `_detectObsoleteFiles(): Promise<ObsoleteFile[]>`
  - `_computeHash(filePath: string): Promise<string>`
  - `_installComponent(component: string, force: boolean): Promise<number>`
  - `_checkUpdates(component: string, versionData: VersionData): Promise<FileChange[]>`
  - `_applyUpdate(update: FileChange, force: boolean): Promise<void>`

### Phase 2: Claude Integration Command

**Step 2.1: Implement ClaudeIntegrationManager**
- Create `src/integrations/claude-manager.ts`
- Extend base manager with Claude-specific configuration:
  - 5 component types (reference_sheets, commands, agents, skills, templates)
  - Target directory: `.claude/`
  - Version file: `.claude/.dr-version`
- Implement path resolution for dev vs. production environments

**Step 2.2: Create Claude Command Module**
- Create `src/commands/claude.ts`
- Implement subcommands: `install`, `update`, `remove`, `status`, `list`
- Use `commander` for command registration
- Use `@clack/prompts` for interactive confirmations
- Use `ansis` for colored output

**Step 2.3: Register Claude Command**
- Update `cli.ts` to import and register claude command group
- Add help text examples

### Phase 3: Copilot Integration Command

**Step 3.1: Implement CopilotIntegrationManager**
- Create `src/integrations/copilot-manager.ts`
- Extend base manager with Copilot-specific configuration:
  - 2 component types (agents, skills)
  - Target directory: `.github/`
  - Version file: `.github/.dr-copilot-version`

**Step 3.2: Create Copilot Command Module**
- Create `src/commands/copilot.ts`
- Mirror claude command structure with copilot-specific options

**Step 3.3: Register Copilot Command**
- Update `cli.ts` to import and register copilot command group

### Phase 4: Upgrade Command Enhancement

**Step 4.1: Add Integration Version Checking**
- Modify `commands/upgrade.ts`
- After existing spec/model checks (around line 160), add:
  - Check for `.claude/.dr-version` existence
  - Compare installed version against CLI version
  - Check for `.github/.dr-copilot-version` similarly

**Step 4.2: Display Integration Status**
- Add integration status to upgrade plan display
- Show version mismatch with suggested command

**Step 4.3: Add Upgrade Suggestions**
- When outdated integrations detected, display actionable suggestions
- Format: "Claude integration outdated: 0.0.9 â†’ 0.1.0. Run `dr claude update`"

### Phase 5: Documentation and Build Updates

**Step 5.1: Update CLI_COMMAND_MAPPING.md**
- Change `dr claude` from "âŒ Python only" to "âœ… Both"
- Change `dr copilot` from "âŒ Python only" to "âœ… Both"
- Add notes about command parity

**Step 5.2: Update Build Configuration**
- Modify `esbuild.config.js` to copy integration source files
- Update package.json to include integrations in npm distribution

**Step 5.3: Add Tests**
- Create `tests/unit/integrations/` directory
- Add unit tests for hash utilities
- Add unit tests for base manager methods
- Create `tests/integration/` tests for claude and copilot commands

### Risk Mitigations

| Risk | Mitigation |
|------|------------|
| Path resolution differs between dev and npm install | Test both scenarios explicitly; use `import.meta.url` for reliable path resolution |
| YAML format incompatibility with Python | Use same `yaml` package version patterns; add round-trip tests |
| File permission issues on Unix vs Windows | Use `fs.chmod` for shell scripts; test on both platforms |
| Large skill directories slow down operations | Implement streaming hash computation; show progress indicators |

### Verification Criteria

1. `dr claude install` copies files matching Python CLI behavior
2. `dr claude status` produces output format consistent with Python CLI
3. `dr upgrade` detects outdated integrations and suggests updates
4. `CLI_COMMAND_MAPPING.md` accurately reflects both CLIs supporting these commands
5. All existing tests continue to pass
6. New integration tests provide >80% coverage of new code

---
_Generated by Orchestrator Bot ğŸ¤–_
_Processed by the software_architect agent_

**@tinkermonkey** (human feedback):
One item that should be emphasized:
- The cli build process should copy the integration definition files from their code location ( integrations/ ) and bundle them inside of the cli package so that they can be installed in projects that are using the cli.
- The built cli must only use the integrations that are built into it, and it only uses them to install / update the integrations
- These files are copied into the .claude and .github folders of the projects being documented along with the file with notes the installed version for each of these integrations so the upgrade command can know what version is installed

**software_architect** (agent):
# Architecture Design

---

You've highlighted a critical architectural point that I want to make sure is crystal clear in the implementation approach.

**The Build-Time Bundling Model**

The integration files follow a **compile-time bundling** pattern, not runtime discovery:

```
Build Time                          Runtime (npm package)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
integrations/                       dist/
â”œâ”€â”€ claude_code/        â”€â”€copyâ”€â”€â–º   â”œâ”€â”€ integrations/
â”‚   â”œâ”€â”€ reference_sheets/           â”‚   â”œâ”€â”€ claude_code/
â”‚   â”œâ”€â”€ commands/                   â”‚   â”‚   â””â”€â”€ (all files)
â”‚   â”œâ”€â”€ agents/                     â”‚   â””â”€â”€ github_copilot/
â”‚   â””â”€â”€ skills/                     â”‚       â””â”€â”€ (all files)
â””â”€â”€ github_copilot/                 â””â”€â”€ cli.js
    â”œâ”€â”€ agents/
    â””â”€â”€ skills/
```

**Key Points:**

1. **esbuild.config.js** must copy `integrations/` â†’ `dist/integrations/` during build
2. **package.json "files" array** must include `dist/integrations/**` for npm publish
3. **Runtime path resolution** uses `import.meta.url` to find bundled integrations relative to the compiled CLI, never looking at the original source location
4. **Target project structure** receives copies with version tracking:

```
target-project/
â”œâ”€â”€ .claude/
â”‚   â”œâ”€â”€ knowledge/           # copied from bundled reference_sheets/
â”‚   â”œâ”€â”€ commands/            # copied from bundled commands/
â”‚   â”œâ”€â”€ agents/              # copied from bundled agents/
â”‚   â”œâ”€â”€ skills/              # copied from bundled skills/
â”‚   â””â”€â”€ .dr-version          # tracks installed CLI version + file hashes
â””â”€â”€ .github/
    â”œâ”€â”€ agents/
    â”œâ”€â”€ skills/
    â””â”€â”€ .dr-copilot-version
```

The `.dr-version` file records the CLI version that performed the install, enabling `dr upgrade` to detect when the bundled integrations have changed and prompt for updates. This ensures users get the integration files that match their installed CLI version, not whatever happens to be in some external location.

---
_Generated by Orchestrator Bot ğŸ¤–_
_Processed by the software_architect agent_

IMPORTANT: Review all feedback carefully and address every issue that is not already addressed.


