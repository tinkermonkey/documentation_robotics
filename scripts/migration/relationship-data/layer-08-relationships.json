{
  "layerId": "08",
  "intraLayerRelationships": {
    "count": 11,
    "relationships": [
      {
        "relationshipTypeId": "composition",
        "predicate": "composes",
        "inversePredicate": "composed-of",
        "category": "structural",
        "description": "Whole-part relationship where the part cannot exist without the whole",
        "sourceTypes": ["Database", "DatabaseSchema", "Table"],
        "targetTypes": ["Column", "Constraint", "DatabaseSchema", "Index", "Table"],
        "examples": [
          {
            "source": "Database",
            "target": "DatabaseSchema",
            "description": "Database instance contains one or more schemas",
            "layer": "08-data-store"
          },
          {
            "source": "DatabaseSchema",
            "target": "Table",
            "description": "Schema contains tables as physical storage units",
            "layer": "08-data-store"
          },
          {
            "source": "Table",
            "target": "Column",
            "description": "Table is composed of columns defining its structure",
            "layer": "08-data-store"
          }
        ]
      },
      {
        "relationshipTypeId": "aggregation",
        "predicate": "aggregates",
        "inversePredicate": "aggregated-by",
        "category": "structural",
        "description": "Whole-part relationship where the part can exist independently",
        "sourceTypes": ["Constraint", "Index"],
        "targetTypes": ["Column"],
        "examples": [
          {
            "source": "Index",
            "target": "Column",
            "description": "Index aggregates one or more columns (composite indexes)",
            "layer": "08-data-store"
          },
          {
            "source": "Constraint",
            "target": "Column",
            "description": "Constraint aggregates columns (composite keys, multi-column checks)",
            "layer": "08-data-store"
          }
        ]
      },
      {
        "relationshipTypeId": "specialization",
        "predicate": "specializes",
        "inversePredicate": "generalized-by",
        "category": "structural",
        "description": "Type-subtype relationship (inheritance)",
        "sourceTypes": ["PremiumAccount", "Schema"],
        "targetTypes": ["Account", "Schema"],
        "examples": [
          {
            "source": "PremiumAccount",
            "target": "Account",
            "description": "Premium account specializes the general account concept"
          },
          {
            "source": "Schema",
            "target": "Schema",
            "description": "API schema specializes another via allOf/oneOf/anyOf composition",
            "layer": "06-api"
          }
        ]
      },
      {
        "relationshipTypeId": "triggering",
        "predicate": "triggers",
        "inversePredicate": "triggered-by",
        "category": "behavioral",
        "description": "Event or behavior triggers another behavior",
        "sourceTypes": ["Trigger"],
        "targetTypes": ["Function"],
        "examples": [
          {
            "source": "Trigger",
            "target": "Function",
            "description": "Database trigger executes specified function on event",
            "layer": "08-data-store"
          }
        ]
      },
      {
        "relationshipTypeId": "serving",
        "predicate": "serves",
        "inversePredicate": "served-by",
        "category": "behavioral",
        "description": "Service available to consumer",
        "sourceTypes": ["BusinessService", "ContextVariation", "InputSpacePartition"],
        "targetTypes": ["BusinessActor", "TestCoverageTarget"],
        "examples": [
          {
            "source": "BusinessService",
            "target": "BusinessActor",
            "description": "Business service serves business actor"
          },
          {
            "source": "InputSpacePartition",
            "target": "TestCoverageTarget",
            "description": "Partition serves target by defining testable input space",
            "layer": "12-testing"
          },
          {
            "source": "ContextVariation",
            "target": "TestCoverageTarget",
            "description": "Context serves target by defining execution environments",
            "layer": "12-testing"
          }
        ]
      },
      {
        "relationshipTypeId": "access",
        "predicate": "accesses",
        "inversePredicate": "accessed-by",
        "category": "behavioral",
        "description": "Behavior accesses passive element (data/artifact)",
        "sourceTypes": ["BusinessProcess", "CoverageRequirement", "TestCaseSketch"],
        "targetTypes": ["BusinessObject", "InputPartitionSelection", "InputSelection"],
        "examples": [
          {
            "source": "BusinessProcess",
            "target": "BusinessObject",
            "description": "Business process accesses business object data"
          },
          {
            "source": "TestCaseSketch",
            "target": "InputSelection",
            "description": "Test sketch accesses input selections for test execution",
            "layer": "12-testing"
          },
          {
            "source": "CoverageRequirement",
            "target": "InputPartitionSelection",
            "description": "Requirement accesses partition selections for coverage",
            "layer": "12-testing"
          }
        ]
      },
      {
        "relationshipTypeId": "reference",
        "predicate": "references",
        "inversePredicate": "referenced-by",
        "category": "dependency",
        "description": "Pointer reference without functional dependency",
        "sourceTypes": ["CoverageRequirement", "DataObject", "TestCaseSketch"],
        "targetTypes": ["CoverageRequirement", "Schema", "TestCoverageTarget"],
        "examples": [
          {
            "source": "DataObject",
            "target": "Schema",
            "description": "Data object references JSON schema"
          },
          {
            "source": "TestCaseSketch",
            "target": "CoverageRequirement",
            "description": "Test case sketch references coverage requirement it satisfies",
            "layer": "12-testing"
          },
          {
            "source": "CoverageRequirement",
            "target": "TestCoverageTarget",
            "description": "Coverage requirement references target it covers",
            "layer": "12-testing"
          }
        ]
      },
      {
        "relationshipTypeId": "depends-on",
        "predicate": "depends-on",
        "inversePredicate": "dependency-of",
        "category": "dependency",
        "description": "Element requires another to function",
        "sourceTypes": ["ApplicationService", "TestCaseSketch"],
        "targetTypes": ["ContextVariation", "DataObject", "OutcomeCategory"],
        "examples": [
          {
            "source": "ApplicationService",
            "target": "DataObject",
            "description": "Application service depends on data object"
          },
          {
            "source": "TestCaseSketch",
            "target": "ContextVariation",
            "description": "Test sketch depends on context for execution environment",
            "layer": "12-testing"
          },
          {
            "source": "TestCaseSketch",
            "target": "OutcomeCategory",
            "description": "Test sketch depends on expected outcome category",
            "layer": "12-testing"
          }
        ]
      },
      {
        "relationshipTypeId": "maps-to",
        "predicate": "maps-to",
        "inversePredicate": "mapped-from",
        "category": "data",
        "description": "Schema/table mapping",
        "sourceTypes": ["DataObject"],
        "targetTypes": ["DatabaseTable"],
        "examples": [
          {
            "source": "DataObject",
            "target": "DatabaseTable",
            "description": "User data object maps to users table"
          }
        ]
      },
      {
        "relationshipTypeId": "references-table",
        "predicate": "references-table",
        "inversePredicate": "table-referenced-by",
        "category": "data",
        "description": "Foreign key relationships",
        "sourceTypes": ["OrderTable"],
        "targetTypes": ["CustomerTable"],
        "examples": [
          {
            "source": "OrderTable",
            "target": "CustomerTable",
            "description": "Order table references customer table via foreign key"
          }
        ]
      },
      {
        "relationshipTypeId": "derivedfrom",
        "predicate": "derives-from",
        "inversePredicate": "derived-by",
        "category": "data",
        "description": "Calculated field relationships",
        "sourceTypes": ["TotalPrice"],
        "targetTypes": ["Quantity, UnitPrice"],
        "examples": [
          {
            "source": "TotalPrice",
            "target": "Quantity, UnitPrice",
            "description": "Total price derives from quantity times unit price"
          }
        ]
      }
    ]
  },
  "crossLayerRelationships": {
    "outgoing": {
      "count": 3,
      "relationships": [
        {
          "id": "motivation-governed-by-principles",
          "predicate": "governed-by-principles",
          "inversePredicate": "governs",
          "targetLayer": "01-motivation",
          "targetTypes": ["GovernedByPrinciple"],
          "sourceTypes": ["BusinessService"],
          "fieldPath": "motivation.governed-by-principles",
          "cardinality": "array",
          "format": "reference",
          "strength": "high",
          "required": false,
          "description": "BusinessService governed by Principles",
          "examples": [
            {
              "elementType": "BusinessService",
              "elementId": "order-service",
              "elementName": "Order Processing Service",
              "fieldPath": "motivation.governed-by-principles",
              "value": "principle-customer-first,principle-automation",
              "layer": "02-business"
            },
            {
              "elementType": "ApplicationService",
              "elementId": "product-service",
              "elementName": "product-service",
              "fieldPath": "motivation.governed-by-principles",
              "value": "principle-api-first,principle-cloud-native",
              "layer": "04-application"
            }
          ]
        },
        {
          "id": "motivation-supports-goals",
          "predicate": "supports-goals",
          "inversePredicate": "supported-by",
          "targetLayer": "01-motivation",
          "targetTypes": ["SupportsGoal"],
          "sourceTypes": ["BusinessService"],
          "fieldPath": "motivation.supports-goals",
          "cardinality": "array",
          "format": "reference",
          "strength": "high",
          "required": false,
          "description": "BusinessService supports Goals",
          "examples": [
            {
              "elementType": "BusinessService",
              "elementId": "order-service",
              "elementName": "Order Processing Service",
              "fieldPath": "motivation.supports-goals",
              "value": "goal-customer-satisfaction,goal-revenue-growth",
              "layer": "02-business"
            },
            {
              "elementType": "ApplicationService",
              "elementId": "product-service",
              "elementName": "product-service",
              "fieldPath": "motivation.supports-goals",
              "value": "goal-product-catalog-accuracy,goal-customer-satisfaction",
              "layer": "04-application"
            }
          ]
        },
        {
          "id": "security-classification",
          "predicate": "classification",
          "inversePredicate": "referenced-by",
          "targetLayer": "03-security",
          "targetTypes": ["Classification"],
          "sourceTypes": ["Artifact"],
          "fieldPath": "security.classification",
          "cardinality": "single",
          "format": "string",
          "strength": "low",
          "required": false,
          "description": "Links to Classification in target layer",
          "examples": [
            {
              "elementType": "Artifact",
              "elementId": "product-db",
              "elementName": "product-db",
              "fieldPath": "security.classification",
              "value": "internal",
              "layer": "05-technology"
            },
            {
              "elementType": "Artifact",
              "elementId": "customer-db",
              "elementName": "customer-db",
              "fieldPath": "security.classification",
              "value": "restricted",
              "layer": "05-technology"
            }
          ]
        }
      ]
    },
    "incoming": {
      "count": 0,
      "relationships": []
    }
  },
  "markdownDocumentation": {
    "intra_layer_sections": [
      "**Purpose**: Define structural and behavioral relationships between entities within this layer.\n",
      "- **Valid Types**: Composition, Aggregation, Specialization, Triggering, Flow, Access, Serving, Assignment\n- **Source Validation**: Must reference existing entity in this layer\n- **Target Validation**: Must reference existing entity in this layer\n- **Cardinality**: Enforced based on relationship type\n"
    ],
    "cross_layer_sections": [
      "**Purpose**: Define semantic links to entities in other layers, supporting traceability, governance, and architectural alignment.\n",
      "- **Target Existence**: Referenced entities must exist in target layer\n- **Target Type**: Must match allowed target element types\n- **Cardinality**:\n  - Array fields: Multiple references allowed\n  - Single fields: One reference only\n- **Format Validation**:\n  - UUID fields: Valid UUID v4 format\n  - ID fields: Valid identifier format\n  - Enum fields: Must match allowed values\n"
    ],
    "has_content": true
  }
}
